<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Atlas - Architect</title>
    <style>
        :root { --bg: #050505; --panel: #111; --accent: #00d2ff; --text: #ddd; --danger: #ff4444; --success: #00ff88; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif; user-select: none; }

        /* HEADER */
        header { height: 45px; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; background: #080808; border-bottom: 1px solid #333; }
        #back-btn { background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding-right: 15px;}
        .mode-tabs { display: flex; gap: 8px; }
        .tab-btn { background: #222; border: 1px solid #444; color: #888; padding: 6px 14px; cursor: pointer; border-radius: 4px; font-weight: bold; font-size: 11px; letter-spacing: 0.5px;}
        .tab-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
        .action-btn { background: #333; color: white; border: 1px solid #555; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 11px; font-weight: bold; }
        .action-btn:hover { background: #555; }

        /* VIEWPORT */
        #viewport { display: flex; height: calc(100vh - 205px); width: 100%; position: relative; }
        .canvas-container { flex: 1; position: relative; border-right: 1px solid #333; overflow: hidden; background: #000; }
        
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        .cvs-cpu { z-index: 5; opacity: 0; pointer-events: none; transition: opacity 0.2s;} 
        
        .view-label { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 4px; font-size: 12px; pointer-events: none; z-index: 10;}

        /* OVERLAYS */
        #bottom-bar { position: absolute; bottom: 170px; left: 10px; pointer-events: none; display: flex; gap: 10px; z-index: 10; align-items: center;}
        .info-tag { background: rgba(0,0,0,0.8); padding: 6px 12px; font-size: 12px; border: 1px solid #444; border-radius: 4px; pointer-events: auto; font-family: monospace;}
        #lock-indicator { display: none; color: var(--success); border-color: var(--success); font-weight: bold; background: rgba(0,255,136,0.1);}
        #zoom-warning { display: none; color: var(--danger); border-color: var(--danger); font-weight: bold; background: rgba(255,0,0,0.1);}

        /* CONTROLS */
        #controls { height: 160px; background: #080808; border-top: 1px solid #333; padding: 10px 15px; overflow-y: auto; }
        .ctrl-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 15px; align-items: start; }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 10px; color: #aaa; text-transform: uppercase; font-weight: bold; }
        
        input[type="range"] { width: 100%; height: 6px; background: #333; appearance: none; border-radius: 3px; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; }
        select, input[type="text"], input[type="number"] { background: #222; color: #eee; border: 1px solid #444; padding: 6px; border-radius: 4px; font-size: 12px; width: 100%; box-sizing: border-box; font-family: monospace;}
        
        .val-disp { font-size: 10px; color: var(--accent); float: right; }
        .lbl-r { color: #ff6b6b; } .lbl-g { color: #51cf66; } .lbl-b { color: #339af0; }
        .hidden { display: none !important; }

        /* SAVE MODAL */
        #save-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; align-items: center; justify-content: center; }
        .modal-box { background: #151515; border: 1px solid #444; padding: 25px; width: 320px; border-radius: 8px; }
        .modal-row { margin-bottom: 15px; }
    </style>
</head>
<body id="app-body">

<header>
    <button id="back-btn" onclick="window.parent.goBack()">&#8592;</button>
    <div class="mode-tabs">
        <button class="tab-btn active" onclick="app.setMode(0)">FRACTALS</button>
        <button class="tab-btn" onclick="app.setMode(1)">NEBULAE</button>
        <button class="tab-btn" onclick="app.setMode(2)">ATLAS</button>
    </div>
    <div style="flex:1"></div>
    <button class="action-btn" onclick="ui.toggleModal(true)">SAVE VIEW</button>
</header>

<div id="viewport">
    <div class="canvas-container" id="cont-left">
        <div class="view-label" id="lbl-left">Mandelbrot</div>
        <canvas id="gl-left"></canvas>
        <canvas id="cpu-left" class="cvs-cpu"></canvas>
    </div>
    <div class="canvas-container" id="cont-right">
        <div class="view-label" id="lbl-right">Julia Set</div>
        <canvas id="gl-right"></canvas>
        <canvas id="cpu-right" class="cvs-cpu"></canvas>
    </div>
</div>

<div id="bottom-bar">
    <div class="info-tag" id="c-coords">C: -0.7600, 0.1200</div>
    <div class="info-tag" id="lock-indicator" title="Double click canvas to unlock">üîí SEED LOCKED</div>
    <div class="info-tag" id="zoom-warning">‚ö†Ô∏è LIMIT: GPU Float32 rounding causing pixelation.</div>
</div>

<div id="controls">
    <div class="ctrl-grid">
        
        <!-- Interactive Equation Input -->
        <div class="control-group" style="grid-column: span 2;">
            <label>Fractal Equation</label>
            <div style="display:flex; gap: 5px;">
                <select id="sel-preset" style="width: 140px;" onchange="app.loadPreset()">
                    <option value="z^2 + c">Mandelbrot (z¬≤)</option>
                    <option value="z^3 + c">Cubic (z¬≥)</option>
                    <option value="z^4 + c">Quartic (z‚Å¥)</option>
                    <option value="z^5 + c">Quintic (z‚Åµ)</option>
                    <option value="burningship">Burning Ship</option>
                    <option value="tricorn">Tricorn</option>
                    <option value="sin(z) + c">Sine Fractal</option>
                </select>
                <input type="text" id="inp-eq" value="z^2 + c">
                <button class="action-btn" style="background:var(--accent); color:#000;" onclick="app.compile()">UPDATE</button>
            </div>
            <div id="error-log" style="color:var(--danger); font-size:10px; display:none; margin-top:2px;"></div>
        </div>

        <div class="control-group">
            <label>Max Iterations <span id="val-iter" class="val-disp">300</span></label>
            <input type="range" id="sl-iter" min="50" max="10000" value="300">
        </div>

        <div class="control-group">
            <label>Zoom Speed</label>
            <input type="range" id="sl-zoom" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>

        <!-- Nebula Physics -->
        <div class="control-group hidden" id="grp-neb-r">
            <label class="lbl-r">Red Escape Threshold <span id="val-red" class="val-disp">200</span></label>
            <input type="range" id="sl-red" min="0" max="1000" value="200">
        </div>
        <div class="control-group hidden" id="grp-neb-g">
            <label class="lbl-g">Green Escape Threshold <span id="val-grn" class="val-disp">100</span></label>
            <input type="range" id="sl-grn" min="0" max="1000" value="100">
        </div>
        <div class="control-group hidden" id="grp-neb-b">
            <label class="lbl-b">Blue Escape Threshold <span id="val-blu" class="val-disp">50</span></label>
            <input type="range" id="sl-blu" min="0" max="1000" value="50">
        </div>
        <div class="control-group hidden" id="grp-neb-den">
            <label>Nebula Brightness</label>
            <input type="range" id="sl-den" min="0.1" max="5.0" step="0.1" value="1.5">
        </div>

        <!-- Aesthetics -->
        <div class="control-group" id="grp-pal">
            <label>Color Palette</label>
            <select id="sel-pal" onchange="app.triggerReset()">
                <option value="0">Magma</option>
                <option value="1">Viridis</option>
                <option value="2">Ice</option>
                <option value="3">Electric</option>
            </select>
        </div>

        <!-- Atlas Grid Size -->
        <div class="control-group hidden" id="grp-grid">
            <label>Atlas Grid Size <span id="val-grid" class="val-disp">10</span></label>
            <input type="range" id="sl-grid" min="2" max="100" value="10">
        </div>

        <div class="control-group">
            <label>&nbsp;</label>
            <button class="action-btn" style="width:100%" onclick="app.resetPos()">RESET POSITION</button>
        </div>
    </div>
</div>

<!-- SAVE MODAL -->
<div id="save-modal">
    <div class="modal-box">
        <h3 style="margin-top:0; color:white;">Save High-Res Render</h3>
        <div class="modal-row">
            <label style="display:block; margin-bottom:5px; color:#aaa; font-size:10px;">TARGET WINDOW</label>
            <select id="save-view">
                <option value="left">Left Window</option>
                <option value="right" selected>Right Window</option>
            </select>
        </div>
        <div class="modal-row" id="row-res">
            <label style="display:block; margin-bottom:5px; color:#aaa; font-size:10px;">RESOLUTION</label>
            <select id="save-res" onchange="ui.checkCustomRes()">
                <option value="1">Screen Size (Fast)</option>
                <option value="2">HD (1920x1080)</option>
                <option value="4">4K (3840x2160)</option>
                <option value="8">8K (7680x4320)</option>
                <option value="custom">Custom Input...</option>
            </select>
            
            <div id="custom-res-div" style="display:none; margin-top:10px; gap:10px; align-items:center;">
                <input type="number" id="save-w" value="4000" style="width:100%;" placeholder="Width"> x 
                <input type="number" id="save-h" value="4000" style="width:100%;" placeholder="Height">
            </div>
            
            <div style="font-size: 10px; color: var(--accent); margin-top: 10px;">Note: Nebulae are saved natively from the progressive CPU engine to preserve exact trajectory detail.</div>
        </div>
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:20px;">
            <button class="action-btn" onclick="ui.toggleModal(false)">Cancel</button>
            <button class="action-btn" style="background:var(--accent); color:black;" onclick="app.save()">Download Image</button>
        </div>
    </div>
</div>

<script>
// =======================================================
// MODULE 1: EQUATION TRANSLATOR
// =======================================================
function parseEquation(eq) {
    let s = eq.toLowerCase().replace(/\s+/g, '');
    
    // CPU Engine State Routing
    app.state.p.eqMode = 0; // Default
    if (s === 'z^3+c') app.state.p.eqMode = 1;
    else if (s === 'z^4+c') app.state.p.eqMode = 2;
    else if (s === 'z^5+c') app.state.p.eqMode = 3;
    else if (s === 'burningship') app.state.p.eqMode = 4;
    else if (s === 'tricorn') app.state.p.eqMode = 5;
    else if (s === 'sin(z)+c') app.state.p.eqMode = 6;
    else if (s === 'cos(z)+c') app.state.p.eqMode = 7;
    else {
        // Match arbitrary powers like z^7.5 + c
        let m = s.match(/z\^([0-9.]+)\+c/);
        if(m) {
            app.state.p.eqMode = 8;
            app.state.p.customPow = parseFloat(m[1]);
        }
    }

    // GLSL Shader Translation
    if(s === 'burningship') return 'vec2(abs(z.x)*abs(z.x)-abs(z.y)*abs(z.y), 2.0*abs(z.x*z.y))+c';
    if(s === 'tricorn') return 'vec2(z.x*z.x-z.y*z.y, -2.0*z.x*z.y)+c';
    s = s.replace(/z\^2(?!\.)/g, 'csqr(z)'); 
    s = s.replace(/z\^([0-9.]+)/g, (m, p1) => p1.includes('.') ? `cpow(z,${p1})` : `cpow(z,${p1}.0)`);
    s = s.replace(/sin\(z\)/g, 'csin(z)');
    s = s.replace(/cos\(z\)/g, 'ccos(z)');
    return s;
}

// =======================================================
// MODULE 2: WEBGL RENDERER (GPU)
// =======================================================
const GL_CORE = {
    setup: function(canvasId) {
        const cvs = document.getElementById(canvasId);
        const gl = cvs.getContext('webgl', {preserveDrawingBuffer:true});
        
        const vs = `attribute vec2 p; void main(){gl_Position=vec4(p,0,1);}`;
        const fsHead = `
            #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
            #else
            precision mediump float;
            #endif
            
            vec2 csqr(vec2 z) { return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y); }
            vec2 cpow(vec2 z, float n) {
                float r = length(z); if(r < 0.00001) return vec2(0.0);
                float a = atan(z.y, z.x); return pow(r, n) * vec2(cos(a*n), sin(a*n));
            }
            vec2 csin(vec2 z) { float ey = exp(z.y); float e_y = exp(-z.y); return vec2(sin(z.x) * (ey + e_y)/2.0, cos(z.x) * (ey - e_y)/2.0); }
            vec2 ccos(vec2 z) { float ey = exp(z.y); float e_y = exp(-z.y); return vec2(cos(z.x) * (ey + e_y)/2.0, -sin(z.x) * (ey - e_y)/2.0); }
            
            vec3 palette(float t, int id) {
                vec3 a=vec3(0.5), b=vec3(0.5), c=vec3(1.0), d;
                if(id==0) d=vec3(0.3,0.2,0.2); else if(id==1) d=vec3(0.0,0.33,0.67);
                else if(id==2) { c=vec3(0.8); d=vec3(0.15,0.2,0.3); } else { c=vec3(2.0); d=vec3(0.5,0.2,0.25); }
                return a + b * cos(6.28318 * (c * t + d));
            }
        `;

        const fsBody = `
            uniform vec2 u_res; uniform vec2 u_offset; uniform float u_zoom; uniform vec2 u_c;
            uniform int u_mode; uniform int u_view; uniform float u_iter; uniform float u_grid;
            uniform int u_pal;

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
                vec2 z, c;
                bool isAtlas = (u_mode == 2);
                
                if(isAtlas) {
                    vec2 guv = uv * u_grid;
                    vec2 cell = floor(guv);
                    vec2 tile = fract(guv) - 0.5;
                    float rng = 4.0 / u_zoom;
                    z = tile * 3.0;
                    c = u_offset + (cell / u_grid) * rng;
                } else {
                    vec2 p = uv / u_zoom + u_offset;
                    if(u_view == 1) { z = p; c = u_c; } else { z = vec2(0.0); c = p; }
                }

                float iter = 0.0; float m = 0.0;
                for(int i=0; i<10000; i++) {
                    if(float(i) > u_iter) break;
                    
                    z = {{EQ}}; // Dynamically replaced
                    
                    m = dot(z,z);
                    if(m > 100.0) break;
                    iter += 1.0;
                }

                vec3 col = vec3(0.0);
                if(m >= 100.0) {
                    float sn = iter - log2(log2(m)) + 4.0;
                    col = palette(sn * 0.03, u_pal);
                }

                // Screen Space Overlays (prevents float rounding pixelation on dots/lines)
                if(isAtlas) {
                    // Draw clean 1px lines using screen coords
                    vec2 cellScreen = gl_FragCoord.xy / (u_res.y / u_grid);
                    vec2 border = fract(cellScreen);
                    if(border.x < 0.03 || border.y < 0.03) col *= 0.5;
                } else if(u_view == 0) {
                     vec2 screen_c = (u_c - u_offset) * u_zoom;
                     float dist = distance(uv, screen_c);
                     if(dist < 0.012) col = vec3(1.0);
                     else if(dist < 0.016) col = vec3(0.0);
                }
                gl_FragColor = vec4(col, 1.0);
            }
        `;
        
        return { gl, cvs, fsHead, fsBody, vs, prog: null };
    },

    compile: function(ctx, glslEq) {
        const fs = ctx.fsHead + ctx.fsBody.replace('{{EQ}}', glslEq);
        const {gl, vs} = ctx;
        
        const s = (t, src) => {
            const o = gl.createShader(t); gl.shaderSource(o, src); gl.compileShader(o);
            if(!gl.getShaderParameter(o, gl.COMPILE_STATUS)) return gl.getShaderInfoLog(o);
            return o;
        };
        const p = gl.createProgram();
        const vsh = s(gl.VERTEX_SHADER, vs), fsh = s(gl.FRAGMENT_SHADER, fs);
        
        if(typeof vsh === 'string') return vsh; if(typeof fsh === 'string') return fsh;
        
        gl.attachShader(p, vsh); gl.attachShader(p, fsh); gl.linkProgram(p);
        
        const b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        const loc = gl.getAttribLocation(p, 'p');
        gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

        ctx.prog = p;
        return null; // Success
    },

    render: function(ctx, state, isRight) {
        if(!ctx.prog) return;
        const {gl, cvs, prog} = ctx;
        const dpr = window.devicePixelRatio || 1;
        
        if(!state.saving) {
            const w = Math.floor(cvs.clientWidth * dpr);
            const h = Math.floor(cvs.clientHeight * dpr);
            if(cvs.width !== w || cvs.height !== h) { cvs.width = w; cvs.height = h; gl.viewport(0,0,w,h); }
        }

        gl.useProgram(prog);
        const u = (n,v) => { const l=gl.getUniformLocation(prog,n); if(typeof v==='number')gl.uniform1f(l,v); else gl.uniform2f(l,v[0],v[1]); };
        const ui = (n,v) => gl.uniform1i(gl.getUniformLocation(prog,n),v);

        const cam = isRight ? state.right : state.left;
        u('u_res', [cvs.width, cvs.height]);
        u('u_offset', [cam.x, cam.y]); u('u_zoom', cam.z); u('u_c', [state.c.x, state.c.y]);
        u('u_iter', state.p.iter); u('u_grid', state.p.grid);
        ui('u_mode', state.mode); ui('u_view', isRight?1:0); ui('u_pal', state.p.pal);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
};

// =======================================================
// MODULE 3: CPU ENGINE (For True Nebulae & Nebula Atlas)
// =======================================================
class NebulaRenderer {
    constructor(canvasId) {
        this.cvs = document.getElementById(canvasId);
        this.ctx = this.cvs.getContext('2d', {willReadFrequently: true});
        this.hist = null; this.imgData = null;
        this.frames = 0;
    }

    reset() {
        const dpr = window.devicePixelRatio || 1;
        const w = Math.floor(this.cvs.clientWidth * dpr);
        const h = Math.floor(this.cvs.clientHeight * dpr);
        
        if(this.cvs.width !== w || this.cvs.height !== h) {
            this.cvs.width = w; this.cvs.height = h;
            this.hist = new Float32Array(w * h * 3);
            this.imgData = this.ctx.createImageData(w, h);
        }
        if(this.hist) this.hist.fill(0);
        this.frames = 0;
    }

    renderBatch(state, isRight) {
        if(!this.hist) return;
        const w = this.cvs.width; const h = this.cvs.height;
        const cam = isRight ? state.right : state.left;
        
        const vw = (w/h) * (1.0 / cam.z); const vh = 1.0 / cam.z;
        const minX = cam.x - vw/2; const minY = cam.y - vh/2;
        
        const batch = 30000; 
        const p = state.p; const max_i = p.iter;
        const trX = new Float32Array(max_i); const trY = new Float32Array(max_i);

        const isNebulaAtlas = (state.mode === 2 && isRight);
        const grid = p.grid;
        const eqm = p.eqMode;
        const cp = p.customPow;

        this.frames++;

        for(let i=0; i<batch; i++) {
            let cr, ci, zx, zy, cellX, cellY;
            
            if (isNebulaAtlas) {
                // TRUE NEBULA ATLAS LOGIC
                let asp = w/h;
                let uvX = (Math.random() - 0.5) * asp;
                let uvY = (Math.random() - 0.5); 
                
                cellX = Math.floor(uvX * grid);
                cellY = Math.floor(uvY * grid);
                
                cr = cam.x + (cellX / grid) * (4.0 / cam.z);
                ci = cam.y + (cellY / grid) * (4.0 / cam.z);
                
                zx = (Math.random() - 0.5) * 3.0;
                zy = (Math.random() - 0.5) * 3.0;
                
            } else {
                // STANDARD NEBULA LOGIC
                let sr = cam.x + (Math.random()-0.5) * vw * 1.5;
                let si = cam.y + (Math.random()-0.5) * vh * 1.5;
                
                cr = isRight ? state.c.x : sr;
                ci = isRight ? state.c.y : si;
                zx = isRight ? sr : 0.0;
                zy = isRight ? si : 0.0;
            }
            
            let step = 0; let esc = false;
            let d_min = 1000.0;
            
            // Dynamic CPU Equation Unroller
            while(step < max_i) {
                trX[step] = zx; trY[step] = zy;
                let nx, ny;
                
                if(eqm === 0) { nx = zx*zx-zy*zy+cr; ny = 2.0*zx*zy+ci; } // z^2
                else if(eqm === 1) { nx = zx*zx*zx - 3.0*zx*zy*zy + cr; ny = 3.0*zx*zx*zy - zy*zy*zy + ci; } // z^3
                else if(eqm === 2) { nx = zx*zx*zx*zx - 6.0*zx*zx*zy*zy + zy*zy*zy*zy + cr; ny = 4.0*zx*zx*zx*zy - 4.0*zx*zy*zy*zy + ci; } // z^4
                else if(eqm === 3) { let r2=zx*zx+zy*zy; let r4=r2*r2; let r5=r4*Math.sqrt(r2); let a=Math.atan2(zy,zx)*5.0; nx=r5*Math.cos(a)+cr; ny=r5*Math.sin(a)+ci; } // z^5
                else if(eqm === 4) { nx = zx*zx-zy*zy+cr; ny = 2.0*Math.abs(zx*zy)+ci; } // Burning Ship
                else if(eqm === 5) { nx = zx*zx-zy*zy+cr; ny = -2.0*zx*zy+ci; } // Tricorn
                else if(eqm === 6) { let ey=Math.exp(zy), e_y=Math.exp(-zy); nx=Math.sin(zx)*(ey+e_y)/2+cr; ny=Math.cos(zx)*(ey-e_y)/2+ci; } // sin
                else if(eqm === 7) { let ey=Math.exp(zy), e_y=Math.exp(-zy); nx=Math.cos(zx)*(ey+e_y)/2+cr; ny=-Math.sin(zx)*(ey-e_y)/2+ci; } // cos
                else if(eqm === 8) { let r=Math.sqrt(zx*zx+zy*zy); let a=Math.atan2(zy,zx); let rn=Math.pow(r,cp); nx=rn*Math.cos(a*cp)+cr; ny=rn*Math.sin(a*cp)+ci; } // Custom Pow
                else { nx = zx*zx-zy*zy+cr; ny = 2.0*zx*zy+ci; } // Fallback
                
                zx = nx; zy = ny;
                let m = zx*zx + zy*zy;
                if(m < d_min) d_min = m;
                if(m > 100.0) { esc = true; break; }
                step++;
            }
            
            if(esc && step > 0) {
                let glow = Math.exp(-d_min * 10.0); // Orbit density trap
                
                for(let s=0; s<step; s++) {
                    let px, py;
                    
                    if (isNebulaAtlas) {
                        let tzX = trX[s] / 3.0; 
                        let tzY = trY[s] / 3.0;
                        if (tzX < -0.5 || tzX > 0.5 || tzY < -0.5 || tzY > 0.5) continue;
                        
                        let guvX = cellX + tzX + 0.5;
                        let guvY = cellY + tzY + 0.5;
                        
                        px = Math.floor((guvX / grid) * h + w/2);
                        py = Math.floor((guvY / grid) * h + h/2);
                        
                    } else {
                        px = Math.floor((trX[s] - minX) / vw * w);
                        py = Math.floor((trY[s] - minY) / vh * h);
                    }
                    
                    if(px>=0 && px<w && py>=0 && py<h) {
                        let idx = ((h - 1 - py) * w + px) * 3; // Invert Y
                        if(step > p.r) this.hist[idx] += glow; 
                        if(step > p.g) this.hist[idx+1] += glow; 
                        if(step > p.b) this.hist[idx+2] += glow; 
                    }
                }
            }
        }
        
        // --- LOGARITHMIC TONE MAPPING ---
        const data = this.imgData.data;
        const len = w * h * 3;
        
        const baseGain = isRight ? 20.0 : 800.0; 
        const scale = (p.den * baseGain) / this.frames;
        const norm = 1.0 / Math.log1p(baseGain); 

        let j=0;
        for(let i=0; i<len; i+=3) {
            let r = Math.log1p(this.hist[i] * scale) * norm;
            let g = Math.log1p(this.hist[i+1] * scale) * norm;
            let b = Math.log1p(this.hist[i+2] * scale) * norm;
            
            data[j++] = Math.min(255, Math.pow(r, 1.2) * 255);
            data[j++] = Math.min(255, Math.pow(g, 1.2) * 255);
            data[j++] = Math.min(255, Math.pow(b, 1.2) * 255);
            data[j++] = 255;
        }

        this.ctx.putImageData(this.imgData, 0, 0);
        
        // --- OVERLAYS (Drawn perfectly on top) ---
        if(isNebulaAtlas) {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            let ts = h / grid;
            let sx = (w/2) % ts; let sy = (h/2) % ts;
            for(let x=sx; x<w; x+=ts) { this.ctx.moveTo(x, 0); this.ctx.lineTo(x, h); }
            for(let y=sy; y<h; y+=ts) { this.ctx.moveTo(0, y); this.ctx.lineTo(w, y); }
            this.ctx.stroke();
        } else if(!isRight && state.mode !== 2) {
            const sx = (state.c.x - cam.x) / vw * w + (w/2);
            const sy = -(state.c.y - cam.y) / vh * h + (h/2); 
            this.ctx.beginPath();
            this.ctx.arc(sx, sy, 5, 0, Math.PI*2);
            this.ctx.fillStyle = 'white'; this.ctx.fill();
            this.ctx.lineWidth = 2; this.ctx.strokeStyle = 'black'; this.ctx.stroke();
        }
    }
}

// =======================================================
// MODULE 4: APP STATE & UI LOGIC
// =======================================================
const app = {
    state: {
        mode: 0, locked: false, saving: false,
        c: {x: -0.76, y: 0.12},
        left: {x: -0.5, y: 0.0, z: 1.0},
        right: {x: 0.0, y: 0.0, z: 1.0},
        p: { eqMode: 0, customPow: 2, iter: 300, grid: 10, pal: 0, den: 1.5, r: 200, g: 100, b: 50 },
        drag: false, dragPoint: false, active: null, last: {x:0, y:0}
    },
    glCtx: [], nebCtx: [],

    init: function() {
        this.glCtx = [GL_CORE.setup('gl-left'), GL_CORE.setup('gl-right')];
        this.nebCtx = [new NebulaRenderer('cpu-left'), new NebulaRenderer('cpu-right')];
        ui.init();
        this.compile();
        this.loop();
    },

    loadPreset: function() {
        document.getElementById('inp-eq').value = document.getElementById('sel-preset').value;
        this.compile();
    },

    compile: function() {
        const rawEq = document.getElementById('inp-eq').value;
        const glslEq = parseEquation(rawEq);
        
        let errStr = null;
        this.glCtx.forEach(c => {
            let res = GL_CORE.compile(c, glslEq);
            if(res) errStr = res;
        });

        const log = document.getElementById('error-log');
        if(errStr) {
            log.style.display = 'block';
            log.innerText = `GLSL SYNTAX ERROR:\nCould not compile equation: "${rawEq}"\n\nDETAILS:\n${errStr}`;
        } else {
            log.style.display = 'none';
            this.triggerReset();
        }
    },

    triggerReset: function() {
        ui.updParams();
        this.nebCtx[0].reset();
        this.nebCtx[1].reset();
    },

    loop: function() {
        if(!this.state.saving) {
            if(this.state.mode === 0) { 
                GL_CORE.render(this.glCtx[0], this.state, false);
                GL_CORE.render(this.glCtx[1], this.state, true);
            } else if (this.state.mode === 1) {
                this.nebCtx[0].renderBatch(this.state, false);
                this.nebCtx[1].renderBatch(this.state, true);
            } else if (this.state.mode === 2) {
                GL_CORE.render(this.glCtx[0], this.state, false); // Standard Julia Atlas
                this.nebCtx[1].renderBatch(this.state, true);     // True Nebula Atlas
            }
        }
        
        const maxZ = Math.max(this.state.left.z, this.state.right.z);
        document.getElementById('zoom-warning').style.display = (maxZ > 100000 && this.state.mode !== 1) ? 'block' : 'none';
        
        requestAnimationFrame(()=>this.loop());
    },
    
    setMode: function(m) {
        this.state.mode = m;
        
        document.getElementById('app-body').className = m === 1 ? 'mode-nebula' : (m === 2 ? 'mode-atlas' : '');
        document.querySelectorAll('.tab-btn').forEach((b,i)=>b.classList.toggle('active',i===m));
        
        let l="Mandelbrot", r="Julia Set";
        if(m===1) { l="Buddhabrot"; r="Nebula Julia"; }
        if(m===2) { l="Julia Atlas"; r="Nebula Atlas"; } 
        document.getElementById('lbl-left').innerText=l;
        document.getElementById('lbl-right').innerText=r;
        
        // Ensure accurate Canvas visibility overlaps
        document.getElementById('cpu-left').style.opacity = (m === 1) ? '1' : '0';
        document.getElementById('cpu-left').style.pointerEvents = (m === 1) ? 'auto' : 'none';
        document.getElementById('cpu-right').style.opacity = (m === 1 || m === 2) ? '1' : '0';
        document.getElementById('cpu-right').style.pointerEvents = (m === 1 || m === 2) ? 'auto' : 'none';

        ui.updControls();
        this.triggerReset();
    },

    resetPos: function() {
        this.state.left = {x:-0.5, y:0, z:1};
        this.state.right = {x:0, y:0, z:1};
        this.triggerReset();
    },

    save: function() {
        const view = document.getElementById('save-view').value;
        const resChoice = document.getElementById('save-res').value;
        const isRight = (view === 'right');
        
        const useCpuEngine = (this.state.mode === 1) || (this.state.mode === 2 && isRight);
        let targetCvs;
        
        if(useCpuEngine) {
            targetCvs = isRight ? this.nebCtx[1].cvs : this.nebCtx[0].cvs;
        } else {
            this.state.saving = true;
            const ctx = isRight ? this.glCtx[1] : this.glCtx[0];
            const ow = ctx.cvs.width, oh = ctx.cvs.height;
            
            let w = ow, h = oh;
            if(resChoice === '2') { w=1920; h=1080; }
            else if(resChoice === '4') { w=3840; h=2160; }
            else if(resChoice === '8') { w=7680; h=4320; }
            else if(resChoice === 'custom') { 
                w = parseInt(document.getElementById('save-w').value) || 1920;
                h = parseInt(document.getElementById('save-h').value) || 1080;
            }
            
            ctx.cvs.width = w; ctx.cvs.height = h; ctx.gl.viewport(0,0,w,h);
            GL_CORE.render(ctx, this.state, isRight);
            targetCvs = ctx.cvs;
        }
        
        const a = document.createElement('a');
        a.download = `fractal_${view}_${Date.now()}.png`;
        a.href = targetCvs.toDataURL('image/png');
        a.click();
        
        if(!useCpuEngine) {
            const ctx = isRight ? this.glCtx[1] : this.glCtx[0];
            ctx.cvs.width = ctx.cvs.clientWidth * (window.devicePixelRatio||1);
            ctx.cvs.height = ctx.cvs.clientHeight * (window.devicePixelRatio||1);
            this.state.saving = false;
        }
        ui.toggleModal(false);
    }
};

const ui = {
    init: function() {
        this.updParams = () => {
            const v = id => parseFloat(document.getElementById(id).value);
            const p = app.state.p;
            p.iter=v('sl-iter'); p.grid=v('sl-grid'); p.r=v('sl-red'); p.g=v('sl-grn'); p.b=v('sl-blu'); p.den=v('sl-den');
            p.pal = parseInt(document.getElementById('sel-pal').value);
            ['iter','grid','red','grn','blu'].forEach(k => document.getElementById(`val-${k}`).innerText = v(`sl-${k}`));
        };
        
        document.querySelectorAll('input[type=range], select').forEach(e => {
            e.addEventListener('input', this.updParams);
            if(e.id !== 'sel-preset') e.addEventListener('change', () => app.triggerReset()); 
        });
        
        document.querySelectorAll('.canvas-container').forEach((cont, idx) => {
            const isR = idx===1;
            
            cont.addEventListener('dblclick', () => {
               app.state.locked = !app.state.locked;
               document.getElementById('lock-indicator').style.display = app.state.locked ? 'block' : 'none';
            });

            cont.addEventListener('mousedown', e => {
                app.state.active = isR ? 'r' : 'l';
                app.state.last = {x:e.clientX, y:e.clientY};
                
                if(!isR && app.state.mode!==2 && !app.state.locked) {
                    const r = cont.getBoundingClientRect();
                    const cam = app.state.left;
                    const asp = cont.clientWidth/cont.clientHeight;
                    
                    const nx = ((e.clientX - r.left) / cont.clientWidth - 0.5) * asp;
                    const ny = -((e.clientY - r.top) / cont.clientHeight - 0.5); 
                    const worldX = nx / cam.z + cam.x;
                    const worldY = ny / cam.z + cam.y;
                    
                    // Check if clicked exactly on the Point
                    const distWorld = Math.hypot(worldX - app.state.c.x, worldY - app.state.c.y);
                    const pixelDist = distWorld * cam.z * cont.clientHeight;
                    
                    if(pixelDist < 20) {
                        app.state.dragPoint = true;
                        app.state.drag = false;
                    } else {
                        app.state.drag = true;
                        app.state.dragPoint = false;
                        app.state.c.x = worldX; app.state.c.y = worldY;
                        document.getElementById('c-coords').innerText = `C: ${app.state.c.x.toFixed(4)}, ${app.state.c.y.toFixed(4)}`;
                        if(app.state.mode === 1) app.triggerReset();
                    }
                } else {
                    app.state.drag = true;
                    app.state.dragPoint = false;
                }
            });

            cont.addEventListener('mousemove', e => {
                const isActive = (app.state.active === (isR?'r':'l'));
                
                // Point Dragging Math
                if(app.state.dragPoint && isActive && !isR) {
                    const r = cont.getBoundingClientRect();
                    const cam = app.state.left;
                    const asp = cont.clientWidth/cont.clientHeight;
                    
                    const nx = ((e.clientX - r.left) / cont.clientWidth - 0.5) * asp;
                    const ny = -((e.clientY - r.top) / cont.clientHeight - 0.5); 
                    
                    app.state.c.x = nx / cam.z + cam.x;
                    app.state.c.y = ny / cam.z + cam.y;
                    
                    document.getElementById('c-coords').innerText = `C: ${app.state.c.x.toFixed(4)}, ${app.state.c.y.toFixed(4)}`;
                    if(app.state.mode === 1) app.triggerReset();
                } 
                // Camera Panning Math
                else if(app.state.drag && isActive) {
                    const cam = isR ? app.state.right : app.state.left;
                    const dx = e.clientX - app.state.last.x;
                    const dy = e.clientY - app.state.last.y;
                    app.state.last = {x:e.clientX, y:e.clientY};
                    
                    // Perfect 1:1 ratio adjustments
                    let factor = 1.0 / (cont.clientHeight * cam.z);
                    if(app.state.mode === 2) factor *= 4.0; 
                    
                    cam.x -= dx * factor; 
                    cam.y += dy * factor;
                    if(app.state.mode === 1 || app.state.mode === 2) app.triggerReset();
                }
            });

            cont.addEventListener('wheel', e => {
                e.preventDefault();
                const cam = isR ? app.state.right : app.state.left;
                const spd = parseFloat(document.getElementById('sl-zoom').value) * 0.1;
                if(e.deltaY < 0) cam.z *= (1+spd); else cam.z /= (1+spd);
                if(app.state.mode === 1 || app.state.mode === 2) app.triggerReset();
            });
        });
        
        window.addEventListener('mouseup', () => { 
            app.state.drag = false; 
            app.state.dragPoint = false; 
        });
    },
    
    toggleModal: function(show) { 
        document.getElementById('save-modal').style.display = show?'flex':'none'; 
        const isNebMode = (app.state.mode === 1) || (app.state.mode === 2 && document.getElementById('save-view').value === 'right');
        document.getElementById('row-res').style.display = isNebMode ? 'none' : 'block';
    },

    checkCustomRes: function() {
        const val = document.getElementById('save-res').value;
        document.getElementById('custom-res-div').style.display = (val === 'custom') ? 'flex' : 'none';
    },
    
    updControls: function() {
        const m = app.state.mode;
        const s = (id, show) => document.getElementById(id).classList.toggle('hidden', !show);
        
        s('grp-neb-r', m===1 || m===2); 
        s('grp-neb-g', m===1 || m===2); 
        s('grp-neb-b', m===1 || m===2); 
        s('grp-neb-den', m===1 || m===2);
        s('grp-pal', m!==1);
        s('grp-grid', m===2);
    }
};

window.onload = () => app.init();
</script>
</body>
</html>
