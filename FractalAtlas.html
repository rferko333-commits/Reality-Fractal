<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fractal Atlas - Architect</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #121212;
            --border-color: #333;
            --accent-color: #00d2ff;
            --text-color: #e0e0e0;
            --text-dim: #888;
            --danger-color: #ff4444;
            --success-color: #00ff88;
        }

        body, html {
            margin: 0; padding: 0;
            height: 100%; width: 100%;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* --- HEADER --- */
        header {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            background-color: #080808;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            z-index: 100;
        }

        #back-btn {
            background: none; border: none; color: white;
            font-size: 24px; cursor: pointer; padding: 0 15px;
        }

        .mode-tabs { display: flex; gap: 8px; }
        
        .tab-btn {
            background: #222;
            border: 1px solid #444;
            color: #888;
            padding: 6px 14px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            font-size: 11px;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }
        
        .tab-btn.active {
            background: var(--accent-color);
            color: #000;
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.3);
        }

        .icon-btn {
            background: none; border: none; color: #ccc;
            font-size: 24px; cursor: pointer; padding: 0 10px;
        }

        /* --- MAIN LAYOUT --- */
        #main-wrapper {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 50px);
        }

        #viewport {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            border-right: 1px solid var(--border-color);
            background: #000;
            overflow: hidden;
        }

        /* Stack Canvases: WebGL (Base) + 2D (Overlay/Nebula) */
        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            outline: none;
        }

        .cvs-cpu {
            pointer-events: none; /* Default: Let GL handle mouse */
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }

        /* Show CPU canvas when needed */
        body.mode-nebula #cpu-left, 
        body.mode-nebula #cpu-right, 
        body.mode-atlas #cpu-right {
            opacity: 1;
            pointer-events: auto;
        }

        /* Overlays */
        .view-label {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px; border-radius: 4px;
            font-size: 12px; pointer-events: none; z-index: 20;
            border: 1px solid #333;
        }

        #bottom-bar-info {
            position: absolute; bottom: 15px; left: 15px;
            display: flex; gap: 10px; pointer-events: none; z-index: 30;
        }

        .info-tag {
            background: rgba(0, 0, 0, 0.85);
            padding: 6px 10px; font-size: 11px; font-family: monospace;
            border: 1px solid #444; border-radius: 4px; pointer-events: auto;
        }

        .tag-lock { color: var(--success-color); border-color: var(--success-color); display: none; }
        .tag-warn { color: var(--danger-color); border-color: var(--danger-color); display: none; }

        /* --- CONTROLS AREA --- */
        #bottom-controls {
            height: 180px;
            background: var(--panel-bg);
            border-top: 1px solid var(--border-color);
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Slide-Out Menu (Mobile) */
        #settings-menu {
            position: fixed; top: 50px; right: 0; bottom: 0; width: 320px;
            background: rgba(18, 18, 18, 0.98);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-left: 1px solid var(--border-color);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 200; display: flex; flex-direction: column;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }
        #settings-menu.open { transform: translateX(0); }
        .settings-content { flex: 1; overflow-y: auto; padding: 20px; }
        h3.settings-title { margin: 0 0 20px 0; color: white; }

        /* --- WIDGETS --- */
        .ctrl-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px; width: 100%;
        }
        .control-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 5px; }
        
        label {
            font-size: 10px; color: var(--text-dim);
            text-transform: uppercase; font-weight: 700;
        }

        .hybrid-input { display: flex; align-items: center; gap: 10px; }

        input[type="range"] {
            flex: 1; height: 6px; background: #333; border-radius: 3px; appearance: none; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 16px; height: 16px;
            background: var(--accent-color); border-radius: 50%; border: 2px solid #fff;
        }

        input[type="number"], input[type="text"], select {
            background: #222; border: 1px solid #444; color: white; padding: 6px;
            border-radius: 4px; font-size: 12px; font-family: monospace;
        }
        input[type="number"] { width: 60px; }
        select { width: 100%; cursor: pointer; }

        .action-btn {
            background: #333; color: white; border: 1px solid #555;
            padding: 10px; border-radius: 4px; font-weight: bold; font-size: 12px;
            cursor: pointer; text-align: center; transition: background 0.2s;
        }
        .action-btn:hover { background: #444; }
        .btn-primary { background: var(--accent-color); color: black; border: none; }
        .btn-primary:hover { background: #33eebb; }

        .hidden { display: none !important; }

        /* --- SAVE MODAL --- */
        #save-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 500;
            align-items: center; justify-content: center;
        }
        .modal-box {
            background: #181818; border: 1px solid #444; padding: 25px;
            width: 90%; max-width: 350px; border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }

        #error-log {
            display: none; position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(50, 0, 0, 0.95); border: 1px solid red; color: #ffaaaa;
            padding: 15px; border-radius: 6px; z-index: 300; font-family: monospace;
            font-size: 11px; white-space: pre-wrap; max-width: 80%;
        }

        @media (max-width: 768px) {
            #viewport { flex-direction: column; }
            .canvas-container { border-right: none; border-bottom: 1px solid #333; }
            #bottom-controls { display: none; } /* Hide bottom on phone */
            #info-overlay { bottom: 10px; }
            #settings-menu { width: 85%; }
        }
    </style>
</head>
<body id="app-body">

    <header>
        <button id="back-btn" onclick="window.parent.goBack()">&#8592;</button>
        <div class="mode-tabs">
            <button class="tab-btn active" onclick="app.setMode(0)">FRACTALS</button>
            <button class="tab-btn" onclick="app.setMode(1)">NEBULAE</button>
            <button class="tab-btn" onclick="app.setMode(2)">ATLAS</button>
        </div>
        <button class="icon-btn" onclick="ui.toggleSettings()">‚öôÔ∏è</button>
    </header>

    <div id="main-wrapper">
        <div id="viewport">
            <div class="canvas-container" id="cont-left">
                <div class="view-label" id="lbl-left">Mandelbrot</div>
                <canvas id="gl-left"></canvas>
                <canvas id="cpu-left" class="cvs-cpu"></canvas>
            </div>

            <div class="canvas-container" id="cont-right">
                <div class="view-label" id="lbl-right">Julia Set</div>
                <canvas id="gl-right"></canvas>
                <canvas id="cpu-right" class="cvs-cpu"></canvas>
            </div>

            <div id="bottom-bar-info">
                <div class="info-tag" id="c-coords">C: -0.7600, 0.1200</div>
                <div class="info-tag tag-lock" id="lock-indicator">üîí LOCKED</div>
                <div class="info-tag tag-warn" id="zoom-warning">‚ö†Ô∏è GPU PRECISION LIMIT</div>
            </div>
            <div id="error-log"></div>
        </div>

        <!-- Desktop Bottom Controls -->
        <div id="bottom-controls"></div>
    </div>

    <!-- Mobile Slide-Out Menu -->
    <div id="settings-menu">
        <div class="settings-content">
            <h3 style="margin-top:0; color:white;">Settings</h3>
            <div id="mobile-controls-target"></div>
        </div>
    </div>

    <!-- Save Modal -->
    <div id="save-modal">
        <div class="modal-box">
            <h3 style="margin-top:0; color:white; margin-bottom:15px;">Save Image</h3>
            <div class="control-group">
                <label>Target Window</label>
                <select id="save-view">
                    <option value="left">Left Window</option>
                    <option value="right" selected>Right Window</option>
                </select>
            </div>
            <div class="control-group" id="row-res">
                <label>Resolution</label>
                <select id="save-res" onchange="ui.checkCustomRes()">
                    <option value="1">Screen Size (Fast)</option>
                    <option value="2">HD (1920 x 1080)</option>
                    <option value="4">4K (3840 x 2160)</option>
                    <option value="8">8K (7680 x 4320)</option>
                    <option value="custom">Custom Keyboard Input...</option>
                </select>
                <div id="custom-res-div" style="display:none; gap:10px; margin-top:10px; align-items:center;">
                    <input type="number" id="save-w" value="3000" placeholder="W">
                    <span style="color:#888">x</span>
                    <input type="number" id="save-h" value="3000" placeholder="H">
                </div>
                <p style="font-size:10px; color:#888; margin-top:5px; line-height:1.4;">
                    Note: Nebulae/Buddhabrots are saved exactly as seen on screen. Standard fractals are re-rendered at high res.
                </p>
            </div>
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button class="action-btn" onclick="ui.toggleModal(false)" style="flex:1">Cancel</button>
                <button class="action-btn btn-primary" onclick="app.save()" style="flex:1">Download</button>
            </div>
        </div>
    </div>

<script>
/**
 * FRACTAL ATLAS - ARCHITECT EDITION (FIXED)
 * 1. WebGL Renderer (GL_CORE)
 * 2. Nebula Renderer (NebulaRenderer)
 * 3. App Controller (app)
 * 4. UI Controller (ui)
 */

// --- EQUATION PARSER ---
function parseEquation(eq) {
    let s = eq.toLowerCase().replace(/\s+/g, '');
    
    // CPU Mode Routing
    app.state.p.eqMode = 0; 
    if (s === 'z^3+c') app.state.p.eqMode = 1;
    else if (s === 'z^4+c') app.state.p.eqMode = 2;
    else if (s === 'z^5+c') app.state.p.eqMode = 3;
    else if (s === 'burningship') app.state.p.eqMode = 4;
    else if (s === 'tricorn') app.state.p.eqMode = 5;
    else if (s === 'sin(z)+c') app.state.p.eqMode = 6;
    else if (s === 'cos(z)+c') app.state.p.eqMode = 7;
    else {
        let m = s.match(/z\^([0-9.]+)\+c/);
        if(m) { app.state.p.eqMode = 8; app.state.p.customPow = parseFloat(m[1]); }
    }

    // GLSL Translation
    if(s === 'burningship') return 'vec2(abs(z.x)*abs(z.x)-abs(z.y)*abs(z.y), 2.0*abs(z.x*z.y))+c';
    if(s === 'tricorn') return 'vec2(z.x*z.x-z.y*z.y, -2.0*z.x*z.y)+c';
    
    s = s.replace(/z\^2(?!\.)/g, 'csqr(z)');
    s = s.replace(/z\^([0-9.]+)/g, (match, p1) => {
        return p1.includes('.') ? `cpow(z,${p1})` : `cpow(z,${p1}.0)`;
    });
    s = s.replace(/sin\(z\)/g, 'csin(z)');
    s = s.replace(/cos\(z\)/g, 'ccos(z)');
    
    return s;
}

// --- WEBGL RENDERER ---
const GL_CORE = {
    setup: function(canvasId) {
        const cvs = document.getElementById(canvasId);
        const gl = cvs.getContext('webgl', {preserveDrawingBuffer: true});
        
        const vs = `attribute vec2 p; void main() { gl_Position = vec4(p, 0.0, 1.0); }`;
        const fsHead = `
            #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
            #else
            precision mediump float;
            #endif
            
            vec2 csqr(vec2 z) { return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y); }
            vec2 cpow(vec2 z, float n) {
                float r = length(z); if(r < 0.00001) return vec2(0.0);
                float a = atan(z.y, z.x); return pow(r, n) * vec2(cos(a*n), sin(a*n));
            }
            vec2 csin(vec2 z) { float ey = exp(z.y); float e_y = exp(-z.y); return vec2(sin(z.x)*(ey+e_y)/2.0, cos(z.x)*(ey-e_y)/2.0); }
            vec2 ccos(vec2 z) { float ey = exp(z.y); float e_y = exp(-z.y); return vec2(cos(z.x)*(ey+e_y)/2.0, -sin(z.x)*(ey-e_y)/2.0); }
            
            vec3 palette(float t, int id) {
                vec3 a=vec3(0.5), b=vec3(0.5), c=vec3(1.0), d;
                if(id==0) { c=vec3(1.0); d=vec3(0.0, 0.33, 0.67); } // Magma
                else if(id==1) { c=vec3(1.0); d=vec3(0.3, 0.2, 0.2); } // Viridis
                else if(id==2) { c=vec3(0.8); d=vec3(0.15,0.2,0.3); } // Ice
                else { c=vec3(2.0); d=vec3(0.5,0.2,0.25); } // Electric
                return a + b * cos(6.28318 * (c * t + d));
            }
        `;

        const fsBody = `
            uniform vec2 u_res; uniform vec2 u_offset; uniform float u_zoom; uniform vec2 u_c;
            uniform int u_mode; uniform int u_view; uniform float u_iter; uniform float u_grid;
            uniform int u_pal;

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_res) / u_res.y;
                vec2 z, c;
                bool isAtlas = (u_mode == 2);
                
                if (isAtlas) {
                    // World Space Grid Logic
                    vec2 worldPos = uv / u_zoom + u_offset;
                    float tileSize = 4.0 / u_grid; 
                    vec2 cell = floor(worldPos / tileSize);
                    c = (cell + 0.5) * tileSize;
                    vec2 local = (worldPos - c) / tileSize;
                    z = local * 3.0; 
                } else {
                    vec2 p = uv / u_zoom + u_offset;
                    if (u_view == 1) { z = p; c = u_c; } else { z = vec2(0.0); c = p; }
                }

                float iter = 0.0; float m = 0.0;
                for (int i = 0; i < 10000; i++) {
                    if (float(i) > u_iter) break;
                    z = {{EQ}}; // Injection Point
                    m = dot(z,z);
                    if (m > 100.0) break;
                    iter += 1.0;
                }

                vec3 col = vec3(0.0);
                if (m >= 100.0) {
                    float sn = iter - log2(log2(m)) + 4.0;
                    col = palette(sn * 0.03, u_pal);
                }

                if (isAtlas) {
                    // Grid Overlay (World Space Math)
                    float tileSize = 4.0 / u_grid;
                    vec2 worldPos = uv / u_zoom + u_offset;
                    vec2 distToEdge = abs(fract(worldPos / tileSize + 0.5) - 0.5) * tileSize;
                    vec2 pixelDist = distToEdge * u_zoom * u_res.y;
                    if (min(pixelDist.x, pixelDist.y) < 1.0) col = vec3(0.1);
                } else if (u_view == 0) {
                     vec2 screen_c = (u_c - u_offset) * u_zoom;
                     float dist = distance(uv, screen_c);
                     if (dist < 0.012) col = vec3(1.0);
                     else if (dist < 0.016) col = vec3(0.0);
                }
                gl_FragColor = vec4(col, 1.0);
            }
        `;
        
        return { gl, cvs, fsHead, fsBody, vs, prog: null };
    },

    compile: function(ctx, glslEq) {
        const fs = ctx.fsHead + ctx.fsBody.replace('{{EQ}}', glslEq);
        const {gl, vs} = ctx;
        
        const s = (t, src) => {
            const o = gl.createShader(t); gl.shaderSource(o, src); gl.compileShader(o);
            if(!gl.getShaderParameter(o, gl.COMPILE_STATUS)) return gl.getShaderInfoLog(o);
            return o;
        };
        const p = gl.createProgram();
        const vsh = s(gl.VERTEX_SHADER, vs);
        const fsh = s(gl.FRAGMENT_SHADER, fs);
        
        if (typeof vsh === 'string') return vsh;
        if (typeof fsh === 'string') return fsh;
        
        gl.attachShader(p, vsh); gl.attachShader(p, fsh); gl.linkProgram(p);
        
        const b = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, b);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
        const loc = gl.getAttribLocation(p, 'p');
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

        ctx.prog = p;
        return null;
    },

    render: function(ctx, state, isRight) {
        if (!ctx.prog) return;
        const {gl, cvs, prog} = ctx;
        const dpr = window.devicePixelRatio || 1;
        
        if (!state.saving) {
            const w = Math.floor(cvs.clientWidth * dpr);
            const h = Math.floor(cvs.clientHeight * dpr);
            if (cvs.width !== w || cvs.height !== h) {
                cvs.width = w; cvs.height = h; gl.viewport(0, 0, w, h);
            }
        }

        gl.useProgram(prog);
        const u = (n,v) => { const l=gl.getUniformLocation(prog,n); if(typeof v==='number')gl.uniform1f(l,v); else gl.uniform2f(l,v[0],v[1]); };
        const ui = (n,v) => gl.uniform1i(gl.getUniformLocation(prog,n),v);

        const cam = isRight ? state.right : state.left;
        
        u('u_res', [cvs.width, cvs.height]);
        u('u_offset', [cam.x, cam.y]);
        u('u_zoom', cam.z);
        u('u_c', [state.c.x, state.c.y]);
        u('u_iter', state.p.iter);
        u('u_grid', state.p.grid);
        ui('u_mode', state.mode);
        ui('u_view', isRight ? 1 : 0);
        ui('u_pal', state.p.pal);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
};

// --- CPU NEBULA RENDERER ---
class NebulaRenderer {
    constructor(canvasId) {
        this.cvs = document.getElementById(canvasId);
        this.ctx = this.cvs.getContext('2d', {willReadFrequently: true});
        this.hist = null; this.imgData = null; this.frames = 0;
    }

    reset() {
        const dpr = window.devicePixelRatio || 1;
        const w = Math.floor(this.cvs.clientWidth * dpr);
        const h = Math.floor(this.cvs.clientHeight * dpr);
        if (this.cvs.width !== w || this.cvs.height !== h) {
            this.cvs.width = w; this.cvs.height = h;
            this.hist = new Float32Array(w * h * 3);
            this.imgData = this.ctx.createImageData(w, h);
        }
        if (this.hist) this.hist.fill(0);
        this.frames = 0;
    }

    renderBatch(state, isRight) {
        if (!this.hist) return;
        const w = this.cvs.width; const h = this.cvs.height;
        const cam = isRight ? state.right : state.left;
        
        const vh = 1.0 / cam.z; const vw = (w/h) * vh;
        const minX = cam.x - vw/2; const minY = cam.y - vh/2;
        
        const batch = 30000; const p = state.p; const max_i = p.iter;
        const trX = new Float32Array(max_i); const trY = new Float32Array(max_i);

        const isNebulaAtlas = (state.mode === 2 && isRight);
        const grid = p.grid; const eqm = p.eqMode; const cp = p.customPow;

        this.frames++;

        for(let i=0; i<batch; i++) {
            let cr, ci, zx, zy, cellX, cellY;
            if (isNebulaAtlas) {
                let asp = w/h;
                let uvX = (Math.random() - 0.5) * asp;
                let uvY = (Math.random() - 0.5); 
                let worldX = cam.x + uvX * (1.0/cam.z);
                let worldY = cam.y + uvY * (1.0/cam.z);
                let tileSize = 4.0 / grid;
                
                cellX = Math.floor(worldX / tileSize);
                cellY = Math.floor(worldY / tileSize);
                cr = (cellX + 0.5) * tileSize;
                ci = (cellY + 0.5) * tileSize;
                zx = (Math.random() - 0.5) * 3.0;
                zy = (Math.random() - 0.5) * 3.0;
            } else {
                let sr = cam.x + (Math.random()-0.5) * vw * 1.5;
                let si = cam.y + (Math.random()-0.5) * vh * 1.5;
                cr = isRight ? state.c.x : sr;
                ci = isRight ? state.c.y : si;
                zx = isRight ? sr : 0.0;
                zy = isRight ? si : 0.0;
            }
            
            let step = 0; let esc = false; let d_min = 1000.0;
            
            while(step < max_i) {
                trX[step] = zx; trY[step] = zy;
                let nx, ny;
                if(eqm === 0) { nx = zx*zx-zy*zy+cr; ny = 2.0*zx*zy+ci; } 
                else if(eqm === 1) { nx = zx*zx*zx - 3.0*zx*zy*zy + cr; ny = 3.0*zx*zx*zy - zy*zy*zy + ci; } 
                else if(eqm === 2) { nx = zx*zx*zx*zx - 6.0*zx*zx*zy*zy + zy*zy*zy*zy + cr; ny = 4.0*zx*zx*zx*zy - 4.0*zx*zy*zy*zy + ci; } 
                else if(eqm === 3) { let r2=zx*zx+zy*zy; let r4=r2*r2; let r5=r4*Math.sqrt(r2); let a=Math.atan2(zy,zx)*5.0; nx=r5*Math.cos(a)+cr; ny=r5*Math.sin(a)+ci; } 
                else if(eqm === 4) { nx = zx*zx-zy*zy+cr; ny = 2.0*Math.abs(zx*zy)+ci; } 
                else if(eqm === 5) { nx = zx*zx-zy*zy+cr; ny = -2.0*zx*zy+ci; } 
                else if(eqm === 6) { let ey=Math.exp(zy), e_y=Math.exp(-zy); nx=Math.sin(zx)*(ey+e_y)/2+cr; ny=Math.cos(zx)*(ey-e_y)/2+ci; } 
                else if(eqm === 7) { let ey=Math.exp(zy), e_y=Math.exp(-zy); nx=Math.cos(zx)*(ey+e_y)/2+cr; ny=-Math.sin(zx)*(ey-e_y)/2+ci; } 
                else if(eqm === 8) { let r=Math.sqrt(zx*zx+zy*zy); let a=Math.atan2(zy,zx); let rn=Math.pow(r,cp); nx=rn*Math.cos(a*cp)+cr; ny=rn*Math.sin(a*cp)+ci; } 
                else { nx = zx*zx-zy*zy+cr; ny = 2.0*zx*zy+ci; } 
                zx = nx; zy = ny;
                let m = zx*zx + zy*zy;
                if(m < d_min) d_min = m;
                if(m > 100.0) { esc = true; break; }
                step++;
            }
            
            if(esc && step > 0) {
                let glow = Math.exp(-d_min * 10.0); 
                for(let s=0; s<step; s++) {
                    let px, py;
                    if (isNebulaAtlas) {
                        let tileSize = 4.0 / grid;
                        let wx = (cellX + 0.5) * tileSize + (trX[s] / 3.0) * tileSize;
                        let wy = (cellY + 0.5) * tileSize + (trY[s] / 3.0) * tileSize;
                        px = Math.floor((wx - minX) / vw * w);
                        py = Math.floor((wy - minY) / vh * h);
                    } else {
                        px = Math.floor((trX[s] - minX) / vw * w);
                        py = Math.floor((trY[s] - minY) / vh * h);
                    }
                    if(px>=0 && px<w && py>=0 && py<h) {
                        let idx = ((h - 1 - py) * w + px) * 3;
                        if(step > p.r) this.hist[idx] += glow; 
                        if(step > p.g) this.hist[idx+1] += glow; 
                        if(step > p.b) this.hist[idx+2] += glow; 
                    }
                }
            }
        }
        
        // Tone Mapping
        const data = this.imgData.data;
        const len = w * h * 3;
        const baseGain = isRight ? 20.0 : 800.0; 
        const safeFrames = Math.max(1, this.frames);
        const scale = (p.den * baseGain) / safeFrames;
        const norm = 1.0 / Math.log1p(baseGain); 

        let j = 0;
        for(let i=0; i<len; i+=3) {
            let r = Math.log1p(this.hist[i] * scale) * norm;
            let g = Math.log1p(this.hist[i+1] * scale) * norm;
            let b = Math.log1p(this.hist[i+2] * scale) * norm;
            
            let isGrid = false;
            if (isNebulaAtlas) {
                let py = Math.floor((i/3)/w);
                let px = (i/3) % w;
                let wx = minX + (px/w) * vw;
                let wy = minY + ((h-1-py)/h) * vh;
                let tileSize = 4.0 / grid;
                let distToEdgeX = Math.abs(wx - Math.round(wx/tileSize)*tileSize);
                let distToEdgeY = Math.abs(wy - Math.round(wy/tileSize)*tileSize);
                if (distToEdgeX < vw*1.5 || distToEdgeY < vh*1.5) isGrid = true;
            }

            if (isGrid) {
                data[j++] = 30; data[j++] = 30; data[j++] = 30; data[j++] = 255;
            } else {
                data[j++] = Math.min(255, Math.pow(r, 1.2) * 255);
                data[j++] = Math.min(255, Math.pow(g, 1.2) * 255);
                data[j++] = Math.min(255, Math.pow(b, 1.2) * 255);
                data[j++] = 255;
            }
        }
        this.ctx.putImageData(this.imgData, 0, 0);
        
        if(!isRight && state.mode !== 2) {
            const sx = (state.c.x - cam.x) / vw * w + (w/2);
            const sy = -(state.c.y - cam.y) / vh * h + (h/2); 
            this.ctx.beginPath(); this.ctx.arc(sx, sy, 5, 0, Math.PI*2);
            this.ctx.fillStyle = 'white'; this.ctx.fill(); this.ctx.lineWidth = 2; this.ctx.strokeStyle = 'black'; this.ctx.stroke();
        }
    }
}

// --- APP CONTROLLER ---
const app = {
    state: {
        mode: 0, locked: false, saving: false,
        c: {x: -0.76, y: 0.12},
        left: {x: -0.5, y: 0.0, z: 1.0},
        right: {x: 0.0, y: 0.0, z: 1.0},
        p: { eqMode: 0, customPow: 2, iter: 300, grid: 10, pal: 0, den: 1.5, r: 200, g: 100, b: 50 },
        drag: false, dragPoint: false, active: null, last: {x:0, y:0}
    },
    glCtx: [], nebCtx: [],

    init: function() {
        this.glCtx = [GL_CORE.setup('gl-left'), GL_CORE.setup('gl-right')];
        this.nebCtx = [new NebulaRenderer('cpu-left'), new NebulaRenderer('cpu-right')];
        ui.init();
        this.compile();
        this.loop();
    },

    loadPreset: function() {
        document.getElementById('inp-eq').value = document.getElementById('sel-preset').value;
        this.compile();
    },

    compile: function() {
        const rawEq = document.getElementById('inp-eq').value;
        const glslEq = parseEquation(rawEq);
        let errStr = null;
        this.glCtx.forEach(c => {
            let res = GL_CORE.compile(c, glslEq);
            if(res) errStr = res;
        });
        const log = document.getElementById('error-log');
        if(errStr) {
            log.style.display = 'block'; log.innerText = `GLSL SYNTAX ERROR:\nCould not compile equation: "${rawEq}"\n\nDETAILS:\n${errStr}`;
            // Use Fallback
            GL_CORE.compile(this.glCtx[0], 'csqr(z)+c');
            GL_CORE.compile(this.glCtx[1], 'csqr(z)+c');
        } else {
            log.style.display = 'none';
            this.triggerReset();
        }
    },

    triggerReset: function() {
        ui.updParams();
        this.nebCtx[0].reset();
        this.nebCtx[1].reset();
    },

    loop: function() {
        if(!this.state.saving) {
            if(this.state.mode === 0) { 
                GL_CORE.render(this.glCtx[0], this.state, false);
                GL_CORE.render(this.glCtx[1], this.state, true);
            } else if (this.state.mode === 1) {
                this.nebCtx[0].renderBatch(this.state, false);
                this.nebCtx[1].renderBatch(this.state, true);
            } else if (this.state.mode === 2) {
                GL_CORE.render(this.glCtx[0], this.state, false);
                this.nebCtx[1].renderBatch(this.state, true);
            }
        }
        const maxZ = Math.max(this.state.left.z, this.state.right.z);
        document.getElementById('zoom-warning').style.display = (maxZ > 100000 && this.state.mode !== 1) ? 'block' : 'none';
        requestAnimationFrame(()=>this.loop());
    },
    
    setMode: function(m) {
        this.state.mode = m;
        document.getElementById('app-body').className = m === 1 ? 'mode-nebula' : (m === 2 ? 'mode-atlas' : '');
        document.querySelectorAll('.tab-btn').forEach((b,i)=>b.classList.toggle('active',i===m));
        
        let l="Mandelbrot", r="Julia Set";
        if(m===1) { l="Buddhabrot"; r="Nebula Julia"; }
        if(m===2) { l="Julia Atlas"; r="Nebula Atlas"; } 
        document.getElementById('lbl-left').innerText=l;
        document.getElementById('lbl-right').innerText=r;
        
        document.getElementById('cpu-left').style.opacity = (m === 1) ? '1' : '0';
        document.getElementById('cpu-left').style.pointerEvents = (m === 1) ? 'auto' : 'none';
        document.getElementById('cpu-right').style.opacity = (m === 1 || m === 2) ? '1' : '0';
        document.getElementById('cpu-right').style.pointerEvents = (m === 1 || m === 2) ? 'auto' : 'none';

        ui.updControls();
        this.triggerReset();
    },

    resetPos: function() {
        this.state.left = {x:-0.5, y:0, z:1};
        this.state.right = {x:0, y:0, z:1};
        this.triggerReset();
    },

    save: function() {
        const view = document.getElementById('save-view').value;
        const resChoice = document.getElementById('save-res').value;
        const isRight = (view === 'right');
        const useCpuEngine = (this.state.mode === 1) || (this.state.mode === 2 && isRight);
        
        let targetCvs;
        if(useCpuEngine) {
            targetCvs = isRight ? this.nebCtx[1].cvs : this.nebCtx[0].cvs;
        } else {
            this.state.saving = true;
            const ctx = isRight ? this.glCtx[1] : this.glCtx[0];
            const ow = ctx.cvs.width, oh = ctx.cvs.height;
            let w = ow, h = oh;
            if(resChoice === '2') { w=1920; h=1080; }
            else if(resChoice === '4') { w=3840; h=2160; }
            else if(resChoice === '8') { w=7680; h=4320; }
            else if(resChoice === 'custom') { 
                w = parseInt(document.getElementById('save-w').value) || 1920;
                h = parseInt(document.getElementById('save-h').value) || 1080;
            }
            ctx.cvs.width = w; ctx.cvs.height = h; ctx.gl.viewport(0,0,w,h);
            GL_CORE.render(ctx, this.state, isRight);
            targetCvs = ctx.cvs;
        }
        
        const a = document.createElement('a');
        a.download = `fractal_${view}_${Date.now()}.png`;
        a.href = targetCvs.toDataURL('image/png');
        a.click();
        
        if(!useCpuEngine) {
            const ctx = isRight ? this.glCtx[1] : this.glCtx[0];
            ctx.cvs.width = ctx.cvs.clientWidth * (window.devicePixelRatio||1);
            ctx.cvs.height = ctx.cvs.clientHeight * (window.devicePixelRatio||1);
            this.state.saving = false;
        }
        ui.toggleModal(false);
    }
};

// --- UI GENERATOR ---
const ui = {
    buildControls: (prefix = '') => `
        <div class="ctrl-grid">
            <div class="control-group" style="grid-column: span 2; max-width: 400px;">
                <label>Equation</label>
                <div style="display:flex; gap: 5px;">
                    <select id="${prefix}sel-preset" style="flex:1;">
                        <option value="z^2 + c">Mandelbrot (z¬≤)</option> <option value="z^3 + c">Cubic (z¬≥)</option>
                        <option value="z^4 + c">Quartic (z‚Å¥)</option> <option value="z^5 + c">Quintic (z‚Åµ)</option>
                        <option value="burningship">Burning Ship</option> <option value="tricorn">Tricorn</option>
                        <option value="sin(z) + c">Sine</option>
                    </select>
                    <input type="text" id="${prefix}inp-eq" value="z^2 + c" style="flex:1;">
                    <button class="action-btn btn-primary" id="${prefix}btn-compile" style="width:auto; padding:8px 15px;">APPLY</button>
                </div>
            </div>
            <div class="control-group">
                <label>Max Iterations</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-iter" min="50" max="10000" value="300">
                    <input type="number" id="${prefix}nb-iter" value="300">
                </div>
            </div>
            <div class="control-group hidden" id="${prefix}grp-nebula">
                <label style="color:#ff6b6b">Red Threshold</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-red" min="0" max="2000" value="200">
                    <input type="number" id="${prefix}nb-red" value="200">
                </div>
                <label style="color:#51cf66; margin-top:5px;">Green Threshold</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-grn" min="0" max="2000" value="100">
                    <input type="number" id="${prefix}nb-grn" value="100">
                </div>
                <label style="color:#339af0; margin-top:5px;">Blue Threshold</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-blu" min="0" max="2000" value="50">
                    <input type="number" id="${prefix}nb-blu" value="50">
                </div>
            </div>
            <div class="control-group hidden" id="${prefix}grp-nebula-den">
                <label>Nebula Brightness</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-den" min="0.1" max="5.0" step="0.1" value="1.5">
                    <input type="number" id="${prefix}nb-den" value="1.5" step="0.1">
                </div>
            </div>
            <div class="control-group" id="${prefix}grp-pal">
                <label>Palette</label>
                <select id="${prefix}sel-pal">
                    <option value="0">Magma</option> <option value="1">Viridis</option>
                    <option value="2">Ice</option> <option value="3">Electric</option>
                </select>
            </div>
            <div class="control-group hidden" id="${prefix}grp-grid">
                <label>Atlas Grid</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-grid" min="2" max="100" value="10">
                    <input type="number" id="${prefix}nb-grid" value="10">
                </div>
            </div>
            <div class="control-group">
                <label>Zoom Speed</label>
                <div class="hybrid-input">
                    <input type="range" id="${prefix}sl-zoom" min="0.1" max="5.0" step="0.1" value="1.0">
                    <input type="number" id="${prefix}nb-zoom" value="1.0" step="0.1">
                </div>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button class="action-btn" id="${prefix}btn-reset">RESET CAMERA</button>
            </div>
        </div>
    `,
    init: function() {
        document.getElementById('bottom-controls').innerHTML = this.buildControls();
        document.querySelector('#settings-menu .settings-content').insertAdjacentHTML('beforeend', this.buildControls('menu-'));
        const ids = ['sel-preset','inp-eq','sl-iter','sl-red','sl-grn','sl-blu','sl-den','sel-pal','sl-grid','sl-zoom'];
        const numIds = ['nb-iter','nb-red','nb-grn','nb-blu','nb-den','nb-grid','nb-zoom'];
        
        const sync = (src, val) => {
            const base = src.id.replace(/(menu-|sl-|nb-)/g, '');
            // Update all matching elements
            [`sl-${base}`, `nb-${base}`, `menu-sl-${base}`, `menu-nb-${base}`].forEach(id => {
                const el = document.getElementById(id);
                if(el && el !== src) el.value = val;
            });
            app.updParams(); app.triggerReset();
        };

        ids.concat(numIds).forEach(id => {
            const el = document.getElementById(id); const mel = document.getElementById('menu-'+id);
            if(el) {
                if(el.type === 'text' || el.tagName === 'SELECT') {
                    el.addEventListener(el.tagName==='SELECT'?'change':'input', () => { 
                        if(mel) mel.value = el.value; 
                        if(el.id.includes('sel-preset')) { document.getElementById('inp-eq').value = el.value; document.getElementById('menu-inp-eq').value = el.value; }
                        app.updParams(); app.compile(); 
                    });
                } else {
                    el.addEventListener('input', () => sync(el, el.value));
                }
            }
            if(mel) {
                if(mel.type === 'text' || mel.tagName === 'SELECT') {
                    mel.addEventListener(mel.tagName==='SELECT'?'change':'input', () => { 
                        if(el) el.value = mel.value; 
                        if(mel.id.includes('sel-preset')) { document.getElementById('inp-eq').value = mel.value; document.getElementById('menu-inp-eq').value = mel.value; }
                        app.updParams(); app.compile(); 
                    });
                } else {
                    mel.addEventListener('input', () => sync(mel, mel.value));
                }
            }
        });

        // Button Binds
        const bindBtn = (id, func) => {
            const b1 = document.getElementById(id), b2 = document.getElementById('menu-'+id);
            if(b1) b1.onclick = func; if(b2) b2.onclick = func;
        };
        bindBtn('btn-compile', app.compile); bindBtn('btn-reset', app.resetPos);
        
        // Canvas Interactions
        document.querySelectorAll('.canvas-container').forEach((cont, idx) => {
            const isR = idx===1;
            const handleStart = (cx, cy) => {
                app.state.active = isR ? 'r' : 'l'; app.state.drag = true; app.state.last = {x:cx, y:cy};
                if (!isR && !app.state.locked && app.state.mode !== 2) {
                    const r=cont.getBoundingClientRect(), cam=app.state.left, asp=r.width/r.height;
                    const wx = ((cx-r.left)/r.width-0.5)*asp/cam.z + cam.x;
                    const wy = -((cy-r.top)/r.height-0.5)/cam.z + cam.y;
                    const dist = Math.hypot(wx - app.state.c.x, wy - app.state.c.y) * cam.z * r.height;
                    if(dist < 40) { app.state.dragPoint=true; app.state.drag=false; return; }
                    app.state.c.x=wx; app.state.c.y=wy; ui.updateCoords(); app.triggerReset();
                }
            };
            const handleMove = (cx, cy) => {
                if(app.state.active !== (isR?'r':'l')) return;
                const r = cont.getBoundingClientRect(), cam = isR ? app.state.right : app.state.left;
                if(app.state.dragPoint && !isR) {
                    const asp=r.width/r.height;
                    const nx=((cx-r.left)/r.width-0.5)*asp, ny=-((cy-r.top)/r.height-0.5);
                    app.state.c.x = nx/cam.z+cam.x; app.state.c.y = ny/cam.z+cam.y;
                    ui.updateCoords(); app.triggerReset();
                } else if (app.state.drag) {
                    const dx=cx-app.state.last.x, dy=cy-app.state.last.y, asp=r.width/r.height;
                    cam.x -= (dx/r.height)/cam.z; cam.y += (dy/r.height)/cam.z; // Correct 1:1 panning
                    if(app.state.mode!==0) app.triggerReset();
                }
                app.state.last = {x:cx, y:cy};
            };

            cont.addEventListener('dblclick',()=>{app.state.locked=!app.state.locked; document.getElementById('lock-indicator').style.display=app.state.locked?'block':'none';});
            cont.addEventListener('mousedown',e=>handleStart(e.clientX, e.clientY));
            cont.addEventListener('mousemove',e=>{if(app.state.drag||app.state.dragPoint) handleMove(e.clientX, e.clientY);});
            cont.addEventListener('wheel',e=>{
                e.preventDefault(); 
                const c=isR?app.state.right:app.state.left, s=parseFloat(document.getElementById('sl-zoom').value)*0.1; 
                if(e.deltaY<0)c.z*=(1+s); else c.z/=(1+s); 
                if(app.state.mode!==0)app.triggerReset();
            });
            
            // Touch
            let initDist=0, initZoom=1;
            cont.addEventListener('touchstart', e=>{
                if(e.touches.length===1) handleStart(e.touches[0].clientX, e.touches[0].clientY);
                else if(e.touches.length===2) {
                    app.state.drag=false; app.state.dragPoint=false;
                    initDist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                    initZoom = isR ? app.state.right.z : app.state.left.z;
                }
            }, {passive:false});
            cont.addEventListener('touchmove', e=>{
                e.preventDefault();
                if(e.touches.length===1 && (app.state.drag||app.state.dragPoint)) handleMove(e.touches[0].clientX, e.touches[0].clientY);
                else if(e.touches.length===2) {
                    const dist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                    const cam = isR ? app.state.right : app.state.left;
                    cam.z = initZoom * (dist/initDist);
                    if(app.state.mode!==0) app.triggerReset();
                }
            }, {passive:false});
        });
        window.addEventListener('mouseup', ()=>{app.state.drag=false; app.state.dragPoint=false;});
        window.addEventListener('touchend', ()=>{app.state.drag=false; app.state.dragPoint=false;});
    },
    updateCoords: () => document.getElementById('c-coords').innerText=`C: ${app.state.c.x.toFixed(4)}, ${app.state.c.y.toFixed(4)}`,
    toggleSettings: () => document.getElementById('settings-menu').classList.toggle('open'),
    toggleModal: (s) => { document.getElementById('save-modal').style.display=s?'flex':'none'; document.getElementById('row-res').style.display=((app.state.mode===1)||(app.state.mode===2&&document.getElementById('save-view').value==='right'))?'none':'block';},
    checkCustomRes: () => document.getElementById('custom-res-div').style.display=(document.getElementById('save-res').value==='custom')?'flex':'none',
    updControls: () => {
        const m = app.state.mode, s = (id,v) => { document.getElementById(id).classList.toggle('hidden',!v); document.getElementById('menu-'+id).classList.toggle('hidden',!v); };
        s('grp-nebula',m!==0); s('grp-nebula-den', m!==0);
        s('grp-pal', m===0); s('grp-grid', m===2);
    }
};

window.onload = () => app.init();
</script>
</body>
</html>
