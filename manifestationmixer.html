<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manifestation Mixer - Pro Render Edition</title>
    <style>
        :root { --primary: #8b5cf6; --bg: #0f172a; --panel: #1e293b; --text: #e2e8f0; --accent: #38bdf8; --success: #10b981; --danger: #ef4444; --warning: #f59e0b; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: var(--primary); margin-bottom: 20px; letter-spacing: 1px; text-transform: uppercase; border-bottom: 2px solid #334155; padding-bottom: 10px; }
        h2 { color: var(--accent); margin-top: 0; font-size: 1.2rem; border-bottom: 1px solid #334155; padding-bottom: 10px; margin-bottom: 15px; }
        
        .panel { background: var(--panel); padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #334155; }
        
        .control-group { margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px; }
        label { font-weight: bold; width: 140px; color: #cbd5e1; }
        input[type=range] { flex-grow: 1; cursor: pointer; accent-color: var(--primary); }
        
        button { background: var(--primary); color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold; transition: 0.2s; }
        button:hover { filter: brightness(1.2); }
        button:disabled { background: #475569; cursor: not-allowed; opacity: 0.6; }
        
        .btn-record { background: var(--danger); }
        .btn-test { background: var(--warning); color: #000; }
        .btn-stop { background: #64748b; }
        .btn-play { background: var(--success); }
        .btn-scan { background: #475569; font-size: 12px; padding: 8px; }
        
        select { padding: 8px; border-radius: 4px; background: #0f172a; color: white; border: 1px solid #475569; width: 100%; max-width: 300px; }
        input[type=text], input[type=number] { padding: 8px; border-radius: 4px; background: #0f172a; color: white; border: 1px solid #475569; }

        .seq-list { list-style: none; padding: 0; margin-top: 10px; border: 1px solid #334155; border-radius: 6px; overflow: hidden; }
        .seq-item { background: #0f172a; padding: 10px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #334155; font-size: 0.9em; }
        .seq-item:last-child { border-bottom: none; }
        .seq-active { background: #1e3a8a; border-left: 4px solid var(--accent); }
        .seq-controls { display: flex; gap: 5px; margin-top: 10px; }
        
        .clip-list { list-style: none; padding: 0; margin: 0; }
        .clip-item { background: #0f172a; padding: 10px; border-radius: 8px; margin-bottom: 10px; display: flex; align-items: center; gap: 10px; border: 1px solid #334155; flex-wrap: wrap; }
        .clip-item.playing { border-color: var(--success); box-shadow: 0 0 10px rgba(16, 185, 129, 0.2); }
        .clip-name { flex-grow: 1; background: transparent; border: none; color: white; font-size: 1rem; min-width: 150px; }
        
        .file-upload { position: relative; overflow: hidden; display: inline-block; }
        .file-upload input[type=file] { position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; height: 100%; width: 100%; }
        
        .checkbox-wrapper { display: flex; align-items: center; gap: 5px; font-size: 0.9em; color: #cbd5e1; background: #334155; padding: 5px 10px; border-radius: 4px; }
        
        .info-box { background: #0f172a; padding: 15px; border-radius: 8px; font-size: 0.85em; border-left: 4px solid var(--primary); color: #94a3b8; margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;}
        
        .meter-container { width: 100%; height: 6px; background: #334155; border-radius: 3px; overflow: hidden; margin-top: 5px;}
        .meter-fill { height: 100%; width: 0%; background: var(--success); transition: width 0.05s; }
        
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        .master-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: center; }
        .input-label-group { display: flex; flex-direction: column; text-align: left; gap: 5px; }
        .input-label-group label { font-size: 0.8em; color: var(--accent); width: auto; font-weight: normal; }

        @media (max-width: 600px) { 
            .info-box { grid-template-columns: 1fr; } 
            .master-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Manifestation Mixer</h1>

    <!-- 1. Voice Recorder -->
    <div class="panel">
        <h2>1. Voice Recordings</h2>
        <div class="control-group" style="background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #334155;">
            <label>Input Device:</label>
            <div style="flex-grow: 1; display: flex; gap: 5px;">
                <select id="micSelect"><option value="">Default Microphone</option></select>
                <button onclick="scanDevices()" class="btn-scan">‚Üª Scan Inputs</button>
            </div>
        </div>

        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button id="btnTestMic" class="btn-test">üé§ Test Mic</button>
            <div style="font-size: 0.8em; color: #94a3b8; align-self: center;">(Hold to check levels)</div>
        </div>

        <div class="control-group" style="justify-content: start;">
            <button id="btnRecMic" class="btn-record">‚óè Record New Clip</button>
            <button id="btnStopMic" class="btn-stop" disabled>‚ñ† Stop</button>
            <span id="recTime" style="font-family: monospace; color: var(--danger); opacity: 0;">00:00</span>
        </div>
        
        <div class="meter-container"><div id="micMeter" class="meter-fill"></div></div>

        <div style="margin-top: 20px;">
            <ul id="clipList" class="clip-list"></ul>
            <div id="emptyListMsg" style="color: #64748b; text-align: center; font-style: italic;">No recordings yet.</div>
        </div>
    </div>

    <!-- 2. Binaural Generator & Sequencer -->
    <div class="panel">
        <h2>2. Binaural Beats Engine</h2>
        <div class="control-group">
            <label>Load Preset</label>
            <select id="presetSelect" onchange="applyPreset()">
                <option value="custom">-- Select a Preset --</option>
                <optgroup label="Schumann Resonances (Earth)">
                    <option value="schumann1">7.83Hz (Grounding)</option>
                    <option value="schumann2">14.3Hz (Harmonic 2)</option>
                    <option value="schumann3">20.8Hz (Harmonic 3)</option>
                    <option value="schumann4">27.3Hz (Harmonic 4)</option>
                    <option value="schumann5">33.8Hz (Harmonic 5)</option>
                </optgroup>
                <optgroup label="Binaural Beats">
                    <option value="delta">Delta (Deep Sleep - 2Hz)</option>
                    <option value="theta">Theta (Meditation - 6Hz)</option>
                    <option value="alpha">Alpha (Relaxation - 10Hz)</option>
                    <option value="beta">Beta (Focus - 20Hz)</option>
                    <option value="gamma">Gamma (High Energy - 40Hz)</option>
                </optgroup>
                <optgroup label="Solfeggio (Pure Tones)">
                    <option value="174">174Hz (Heal Pain)</option>
                    <option value="285">285Hz (Rejuvenate)</option>
                    <option value="396">396Hz (Remove Fear)</option>
                    <option value="417">417Hz (Wipe Negativity)</option>
                    <option value="528">528Hz (Confidence/Miracles)</option>
                    <option value="639">639Hz (Love)</option>
                    <option value="741">741Hz (Problem solving)</option>
                    <option value="852">852Hz (Intuition)</option>
                    <option value="963">963Hz (Enlightenment)</option>
                    
                </optgroup>
            </select>
        </div>
        <div class="control-group">
            <label>Base Tone (Hz)</label>
            <input type="number" id="baseFreq" value="200" style="width: 60px;">
            <input type="range" id="baseSlider" min="50" max="963" value="200">
        </div>
        <div class="control-group">
            <label>Beat Diff (Hz)</label>
            <input type="number" id="beatFreq" value="7.83" style="width: 60px;">
            <input type="range" id="beatSlider" min="0" max="55" step="0.01" value="7.83">
        </div>
        <div class="control-group">
            <label>Beat Volume</label>
            <input type="range" id="volBinaural" min="0" max="0.5" step="0.01" value="0.2">
        </div>

        <hr style="border-color: #334155; margin: 15px 0;">
        
        <h3 style="font-size: 1rem; color: var(--accent); margin-bottom: 5px;">3. Frequency Sequencer</h3>
        <p style="font-size:0.8em; color:#94a3b8;">Create a frequency sequence. Applied during Render.</p>
        
        <div class="seq-controls" style="background:#0f172a; padding:10px; border-radius:6px; align-items:center;">
            <label style="width:auto;">Target Hz:</label>
            <input type="number" id="seqTarget" value="4" style="width:50px;" min="0" max="55">
            <label style="width:auto; margin-left:10px;">Mins:</label>
            <input type="number" id="seqMins" value="10" style="width:50px;" min="1">
            <button onclick="addSequenceStep()" style="background:var(--accent); font-size:12px; margin-left:auto;">+ Add Stage</button>
        </div>
        <ul id="sequenceList" class="seq-list" style="display:none;"></ul>
        <div id="seqStatus" style="margin-top:10px; font-family:monospace; color:var(--success); min-height:20px;"></div>
        <button id="btnStartSeq" onclick="toggleSequence()" style="width:100%; margin-top:5px; display:none;">‚ñ∂ Preview Sequence (Live)</button>
    </div>

    <!-- 3. Atmosphere -->
    <div class="panel">
        <h2>4. Atmosphere</h2>
        <div class="control-group">
            <label>Generated:</label>
            <select id="noiseType" onchange="if(isEnvPlaying) startAtmosphere(true)">
                <option value="ocean">üåä Ocean Waves (Dynamic)</option>
                <option value="deep_brown">üåë Deep Brown (Smoothed)</option>
                <option value="brown">üü§ Brown Noise (Deep Rumble)</option>
                <option value="pink">üå∏ Pink Noise (Balanced)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Gen Volume</label>
            <input type="range" id="volNoise" min="0" max="0.8" step="0.01" value="0.3">
        </div>
        
        <hr style="border-color: #334155; margin: 15px 0;">
        
        <div class="control-group">
            <label>Custom Audio:</label>
            <div class="file-upload">
                <button class="btn-scan" style="width: 100%;">üìÅ Upload File (MP3/WAV)</button>
                <input type="file" id="customFile" accept="audio/*" onchange="handleFileUpload(this)">
            </div>
            <span id="fileNameDisplay" style="font-size: 0.8em; color: var(--accent); margin-left: 10px;"></span>
        </div>
        <div class="control-group">
            <label>Custom Vol</label>
            <input type="range" id="volCustom" min="0" max="1" step="0.01" value="0.5" oninput="updateCustomVol(this.value)">
        </div>
    </div>

    <!-- 5. Master Controls -->
    <div class="panel" style="border: 2px solid var(--primary);">
        <h2>5. Export & Render</h2>
        <div class="master-grid">
            <div>
                <button id="btnEnvToggle" onclick="toggleEnvironment()" style="width: 100%; padding: 15px;">‚ñ∂ Preview Mix</button>
                <p style="font-size: 0.8em; color: #94a3b8; margin-top:5px;">Check levels before rendering</p>
            </div>
            <div>
                <div style="display:flex; gap:10px; margin-bottom:5px;">
                    <div class="input-label-group" style="flex:2;">
                        <label>File Name</label>
                        <input type="text" id="fileName" value="manifestation_mix" style="width: 100%;">
                    </div>
                    <div class="input-label-group" style="flex:1;">
                        <label>Duration (Mins)</label>
                        <input type="number" id="renderMins" value="20" style="width: 100%;">
                    </div>
                </div>
                
                <div class="checkbox-wrapper" style="margin-bottom: 10px; justify-content: center; background: transparent;">
                    <input type="checkbox" id="lowQuality">
                    <label for="lowQuality" style="width:auto; cursor:pointer;">Lower Quality (Smaller File)</label>
                </div>

                <button id="btnRender" onclick="startOfflineRender()" style="width: 100%; padding: 15px; background: var(--success);">‚ö° Render & Download</button>
                <p id="renderStatus" style="font-size: 0.8em; color: var(--accent); margin-top:5px; height: 1.2em;"></p>
            </div>
        </div>
    </div>

    <!-- Guide -->
    <div class="panel">
        <h2>Frequency Guide</h2>
        <div class="info-box">
            <div>
                <strong>üß† Binaural Beats</strong><br>
                <ul style="padding-left: 20px; margin-top: 5px;">
                    <li><strong>Delta (1-4Hz):</strong> Deep Healing</li>
                    <li><strong>Theta (4-8Hz):</strong> Meditation</li>
                    <li><strong>Alpha (8-14Hz):</strong> Relaxation</li>
                    <li><strong>Beta (14-30Hz):</strong> Focus</li>
                    <li><strong>Gamma (30-50Hz):</strong> Insight</li>
                </ul>
            </div>
            <div>
                <strong>üåç Schumann</strong><br>
                <ul style="padding-left: 20px; margin-top: 5px;">
                    <li><strong>7.83Hz:</strong> Earth Base</li>
                    <li><strong>14.3Hz:</strong> Harmonic 2</li>
                    <li><strong>20.8Hz:</strong> Harmonic 3</li>
                    <li><strong>27.3Hz:</strong> Harmonic 4</li>
                    <li><strong>33.8Hz:</strong> Harmonic 5</li>
                </ul>
            </div>
            <div>
                <strong>‚ú® Solfeggio</strong><br>
                <ul style="padding-left: 20px; margin-top: 5px;">
                    <li><strong>174/285 Hz:</strong> Pain & Healing</li>
                    <li><strong>396 Hz:</strong> Liberate Fear</li>
                    <li><strong>417 Hz:</strong> Wipe Negativity</li>
                    <li><strong>528 Hz:</strong> Miracles</li>
                    <li><strong>639 Hz:</strong> Relationships</li>
                    <li><strong>741 Hz:</strong> Intuition</li>
                    <li><strong>852/963 Hz:</strong> Spirit</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    let audioCtx, masterGain, mainDestination;
    let oscLeft, oscRight, gainBinaural;
    let atmosNode, atmosGain, lfoNode, filterNode;
    let customBuffer, customNode, customGain;
    let isEnvPlaying = false; 

    // Recorder Vars
    let mediaRecorder, micChunks = [];
    let isRecordingMic = false, isTestMicOn = false;
    let testMicNode, testMicGain, recStartTime, micInterval;
    let analyser, dataArray, activeStream = null;
    let clips = [], clipIdCounter = 1;

    // Sequencer
    let sequenceSteps = [];
    let isSeqRunning = false, seqInterval, startHz = 0;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
        }
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
    }

    function applySafetyFade(buffer) {
        const fadeLength = 2000; 
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
            const data = buffer.getChannelData(ch);
            const len = data.length;
            for (let i = 0; i < fadeLength && i < len; i++) { data[i] *= (i / fadeLength); }
            for (let i = 0; i < fadeLength && i < len; i++) { data[len - 1 - i] *= (i / fadeLength); }
        }
    }

    // --- SEQUENCER ---
    function addSequenceStep() {
        const target = parseFloat(document.getElementById('seqTarget').value);
        const mins = parseFloat(document.getElementById('seqMins').value);
        sequenceSteps.push({ target: target, mins: mins });
        renderSequenceList();
        document.getElementById('sequenceList').style.display = 'block';
        document.getElementById('btnStartSeq').style.display = 'block';
    }
    function renderSequenceList() {
        const list = document.getElementById('sequenceList');
        list.innerHTML = "";
        sequenceSteps.forEach((step, index) => {
            const li = document.createElement('li');
            li.className = 'seq-item';
            li.id = `seq-item-${index}`;
            li.innerHTML = `<span>Stage ${index+1}: <strong>${step.target}Hz</strong> for <strong>${step.mins}m</strong></span><button onclick="removeSeqStep(${index})" style="background:transparent; color:#ef4444; padding:2px;">‚úñ</button>`;
            list.appendChild(li);
        });
    }
    function removeSeqStep(index) {
        sequenceSteps.splice(index, 1);
        renderSequenceList();
        if(sequenceSteps.length === 0) {
            document.getElementById('sequenceList').style.display = 'none';
            document.getElementById('btnStartSeq').style.display = 'none';
        }
    }

    function toggleSequence() {
        initAudio();
        const btn = document.getElementById('btnStartSeq');
        if(isSeqRunning) {
            clearInterval(seqInterval);
            isSeqRunning = false;
            btn.innerText = "‚ñ∂ Preview Sequence (Live)";
            btn.style.background = "var(--primary)";
            document.getElementById('seqStatus').innerText = "";
            document.querySelectorAll('.seq-item').forEach(el => el.classList.remove('seq-active'));
        } else {
            if(!isEnvPlaying) toggleEnvironment();
            isSeqRunning = true;
            let currentStepIndex = 0;
            let initialHz = parseFloat(document.getElementById('beatFreq').value); 
            startHz = initialHz;
            
            const runStep = () => {
                if(currentStepIndex >= sequenceSteps.length) { toggleSequence(); return; }
                const step = sequenceSteps[currentStepIndex];
                const durationSecs = step.mins * 60;
                const startTime = Date.now();
                const stepStartHz = startHz;
                
                document.querySelectorAll('.seq-item').forEach(el => el.classList.remove('seq-active'));
                document.getElementById(`seq-item-${currentStepIndex}`).classList.add('seq-active');

                clearInterval(seqInterval);
                seqInterval = setInterval(() => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    if(elapsed >= durationSecs) {
                        updateBeatFreq(step.target);
                        startHz = step.target;
                        currentStepIndex++;
                        runStep();
                    } else {
                        const progress = elapsed / durationSecs;
                        const currentHz = stepStartHz + (step.target - stepStartHz) * progress;
                        updateBeatFreq(currentHz);
                        const remaining = durationSecs - elapsed;
                        const min = Math.floor(remaining/60);
                        const sec = Math.floor(remaining%60).toString().padStart(2,'0');
                        document.getElementById('seqStatus').innerText = `Ramping to ${step.target}Hz... ${currentHz.toFixed(2)}Hz (${min}:${sec})`;
                    }
                }, 100);
            }
            runStep();
            btn.innerText = "‚èπ Stop Sequence";
            btn.style.background = "#64748b";
        }
    }
    function updateBeatFreq(hz) {
        document.getElementById('beatFreq').value = hz.toFixed(2);
        document.getElementById('beatSlider').value = hz;
        if(isEnvPlaying) updateBinaural();
    }

    // --- OFFLINE RENDERER (LOOP ALIGNED + CONCAT) ---
    async function startOfflineRender() {
        const btn = document.getElementById('btnRender');
        const status = document.getElementById('renderStatus');
        let mins = parseFloat(document.getElementById('renderMins').value) || 1;
        
        btn.disabled = true;
        
        // 1. Calculate Total Voice Duration
        let voiceChainDuration = 0;
        if(clips.length > 0) {
            clips.forEach(c => voiceChainDuration += c.buffer.duration);
        }

        // 2. Adjust Duration to fit full loops
        let durationSecs = mins * 60;
        if(voiceChainDuration > 0) {
            const loops = Math.ceil(durationSecs / voiceChainDuration);
            const actualLoops = loops > 0 ? loops : 1;
            durationSecs = actualLoops * voiceChainDuration;
            const newMins = (durationSecs / 60).toFixed(2);
            status.innerText = `Adjusted to ${newMins}m (${actualLoops} loops) to fit voices...`;
        } else {
            status.innerText = "Generating audio (please wait)...";
        }

        // Wait a tick to let UI update
        await new Promise(r => setTimeout(r, 100));
        
        // Quality Setting
        const lowQuality = document.getElementById('lowQuality').checked;
        const sampleRate = lowQuality ? 22050 : 44100;
        
        const offlineCtx = new OfflineAudioContext(2, sampleRate * durationSecs, sampleRate);
        
        // 3. Binaural
        const baseFreq = parseFloat(document.getElementById('baseFreq').value);
        let currentBeat = parseFloat(document.getElementById('beatFreq').value);
        const oL = offlineCtx.createOscillator();
        const oR = offlineCtx.createOscillator();
        const pL = offlineCtx.createStereoPanner(); pL.pan.value = -1;
        const pR = offlineCtx.createStereoPanner(); pR.pan.value = 1;
        const gBin = offlineCtx.createGain();
        gBin.gain.value = document.getElementById('volBinaural').value;
        oL.connect(pL).connect(gBin); oR.connect(pR).connect(gBin);
        gBin.connect(offlineCtx.destination);
        oL.frequency.value = baseFreq;
        
        let timeCursor = 0;
        oR.frequency.setValueAtTime(baseFreq + currentBeat, 0);
        if(sequenceSteps.length > 0) {
            sequenceSteps.forEach(step => {
                const stepDur = step.mins * 60;
                oR.frequency.linearRampToValueAtTime(baseFreq + step.target, timeCursor + stepDur);
                timeCursor += stepDur;
            });
            if(timeCursor < durationSecs) oR.frequency.setValueAtTime(oR.frequency.value, durationSecs);
        } else {
            oR.frequency.setValueAtTime(baseFreq + currentBeat, durationSecs);
        }
        oL.start(); oR.start();

        // 4. Atmosphere
        const noiseType = document.getElementById('noiseType').value;
        const noiseVol = document.getElementById('volNoise').value;
        if(noiseVol > 0) {
            const bufSize = sampleRate * 2;
            const noiseBuf = offlineCtx.createBuffer(1, bufSize, sampleRate);
            const data = noiseBuf.getChannelData(0);
            let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
            for (let i = 0; i < bufSize; i++) {
                let white = Math.random() * 2 - 1;
                if(noiseType === 'brown' || noiseType === 'deep_brown') {
                     let lastOut = 0; data[i] = (lastOut + (0.02 * white)) / 1.02; lastOut = data[i]; data[i] *= 8.0; 
                } else {
                     b0 = 0.99886*b0+white*0.0555179; b1 = 0.99332*b1+white*0.0750759; b2 = 0.96900*b2+white*0.1538520; b3 = 0.86650*b3+white*0.3104856; b4 = 0.55000*b4+white*0.5329522; b5 = -0.7616*b5-white*0.0168981; data[i]=b0+b1+b2+b3+b4+b5+b6+white*0.5362; data[i]*=0.11; b6=white*0.115926;
                }
            }
            const noiseSrc = offlineCtx.createBufferSource();
            noiseSrc.buffer = noiseBuf; noiseSrc.loop = true;
            const noiseGain = offlineCtx.createGain(); noiseGain.gain.value = noiseVol;
            if(noiseType === 'ocean') {
                const filt = offlineCtx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=400;
                const waveGain = offlineCtx.createGain();
                const lfo = offlineCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.15;
                const lfoAmp = offlineCtx.createGain(); lfoAmp.gain.value=0.8;
                lfo.connect(lfoAmp).connect(waveGain.gain);
                noiseSrc.connect(filt).connect(waveGain).connect(noiseGain).connect(offlineCtx.destination);
                lfo.start();
            } else if (noiseType === 'deep_brown') {
                const filt = offlineCtx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=150;
                const boost = offlineCtx.createGain(); boost.gain.value = 1.5;
                noiseSrc.connect(filt).connect(boost).connect(noiseGain).connect(offlineCtx.destination);
            } else { noiseSrc.connect(noiseGain).connect(offlineCtx.destination); }
            noiseSrc.start();
        }

        // 5. VOICE CHAIN (CONCATENATION & LOOPING)
        if(clips.length > 0) {
            // Calculate total frames required for ONE chain
            let totalFrames = 0;
            clips.forEach(c => totalFrames += Math.floor(c.buffer.duration * sampleRate));
            
            if(totalFrames > 0) {
                 const chainBuffer = offlineCtx.createBuffer(2, totalFrames, sampleRate);
                 
                 let offset = 0;
                 // Stitch clips
                 for(let c of clips) {
                     // We must resample if needed, but offlineCtx handles playback rate.
                     // Simple copy assuming sample rates match or browser handles it?
                     // Browser handles resampling on playback, but copyToChannel does not.
                     // We must rely on loop logic or create buffer source for EACH clip and schedule them?
                     // Scheduling is safer for sample rate mismatch.
                     
                     // CHANGE OF PLAN: We cannot use copyToChannel easily if sample rates differ.
                     // Instead, we loop the SEQUENCE of buffer sources.
                 }
                 
                 // Simpler approach for offline ctx: Schedule the chain repeatedly.
                 const chainDuration = voiceChainDuration; 
                 let currentTime = 0;
                 
                 while(currentTime < durationSecs) {
                     // Schedule one full chain
                     for(let c of clips) {
                         if(currentTime >= durationSecs) break;
                         
                         const src = offlineCtx.createBufferSource();
                         src.buffer = c.buffer;
                         let node = src;
                         if(c.isAngelic) {
                             const f = offlineCtx.createBiquadFilter(); f.type='highpass'; f.frequency.value=350;
                             src.connect(f); node = f;
                         }
                         const g = offlineCtx.createGain();
                         g.gain.value = c.gainVal;
                         node.connect(g).connect(offlineCtx.destination);
                         src.start(currentTime);
                         
                         currentTime += c.buffer.duration;
                     }
                 }
            }
        }

        // 6. Custom Audio
        if(customBuffer) {
            const custSrc = offlineCtx.createBufferSource();
            custSrc.buffer = customBuffer; custSrc.loop = true;
            const custG = offlineCtx.createGain(); custG.gain.value = document.getElementById('volCustom').value;
            custSrc.connect(custG).connect(offlineCtx.destination); custSrc.start();
        }

        // RENDER
        try {
            const renderedBuffer = await offlineCtx.startRendering();
            status.innerText = "Encoding WAV...";
            const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
            const url = window.URL.createObjectURL(wavBlob);
            const a = document.createElement("a");
            a.href = url;
            const nameInput = document.getElementById('fileName').value || "manifestation_mix";
            a.download = nameInput.replace(/[^a-z0-9_\-\.]/gi, '_') + ".wav";
            a.click();
            status.innerText = "Done!";
            btn.disabled = false;
        } catch(e) {
            console.error(e);
            status.innerText = "Error during render.";
            btn.disabled = false;
        }
    }

    function bufferToWave(abuffer, len) {
        let numOfChan = abuffer.numberOfChannels,
            length = len * numOfChan * 2 + 44,
            buffer = new ArrayBuffer(length),
            view = new DataView(buffer),
            channels = [], i, sample, offset = 0, pos = 0;
        
        setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan);
        setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan); setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4);

        for(i = 0; i < numOfChan; i++) channels.push(abuffer.getChannelData(i));

        while(pos < len) {
            for(i = 0; i < numOfChan; i++) {
                sample = Math.max(-1, Math.min(1, channels[i][pos]));
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0;
                view.setInt16(44 + offset, sample, true); 
                offset += 2;
            }
            pos++;
        }
        return new Blob([buffer], {type: "audio/wav"});
        function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
        function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
    }

    // --- LIVE PREVIEW & HELPERS ---
    function toggleEnvironment() {
        initAudio();
        const btn = document.getElementById('btnEnvToggle');
        if (isEnvPlaying) {
            if(oscLeft) { oscLeft.stop(); oscLeft = null; }
            if(oscRight) { oscRight.stop(); oscRight = null; }
            if(atmosNode) { atmosNode.stop(); atmosNode = null; }
            if(lfoNode) { lfoNode.stop(); lfoNode = null; }
            if(customNode) { customNode.stop(); customNode = null; }
            isEnvPlaying = false;
            if(isSeqRunning) toggleSequence();
            btn.innerText = "‚ñ∂ Preview Mix";
            btn.style.background = "var(--primary)";
        } else {
            isEnvPlaying = true;
            updateBinaural(true); 
            startAtmosphere();
            btn.innerText = "‚èπ Stop Mix";
            btn.style.background = "#64748b";
        }
    }
    
    // (Standard functions included below)
    function startAtmosphere(restart = false) {
        if(restart && atmosNode) { atmosNode.stop(); if(lfoNode) lfoNode.stop(); }
        if(restart && customNode) { customNode.stop(); customNode = null; }
        if(!isEnvPlaying && !restart) return; 
        const type = document.getElementById('noiseType').value;
        const bufferSize = audioCtx.sampleRate * 2;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
        for (let i = 0; i < bufferSize; i++) {
             let white = Math.random() * 2 - 1;
             if(type === 'brown' || type === 'deep_brown') {
                 let lastOut = 0; data[i] = (lastOut + (0.02 * white)) / 1.02; lastOut = data[i]; data[i] *= 8.0; 
             } else {
                 b0 = 0.99886*b0+white*0.0555179; b1 = 0.99332*b1+white*0.0750759; b2 = 0.96900*b2+white*0.1538520; b3 = 0.86650*b3+white*0.3104856; b4 = 0.55000*b4+white*0.5329522; b5 = -0.7616*b5-white*0.0168981; data[i]=b0+b1+b2+b3+b4+b5+b6+white*0.5362; data[i]*=0.11; b6=white*0.115926;
             }
        }
        atmosNode = audioCtx.createBufferSource(); atmosNode.buffer = buffer; atmosNode.loop = true;
        atmosGain = audioCtx.createGain(); atmosGain.gain.value = document.getElementById('volNoise').value;
        if (type === 'ocean') {
            filterNode = audioCtx.createBiquadFilter(); filterNode.type = 'lowpass'; filterNode.frequency.value = 400; 
            const waveGain = audioCtx.createGain(); lfoNode = audioCtx.createOscillator(); lfoNode.type = 'sine'; lfoNode.frequency.value = 0.15; 
            const lfoStrength = audioCtx.createGain(); lfoStrength.gain.value = 0.8; lfoNode.connect(lfoStrength).connect(waveGain.gain);
            atmosNode.connect(filterNode).connect(waveGain).connect(atmosGain).connect(masterGain); lfoNode.start();
        } else if (type === 'deep_brown') {
            filterNode = audioCtx.createBiquadFilter(); filterNode.type = 'lowpass'; filterNode.frequency.value = 150; 
            const boost = audioCtx.createGain(); boost.gain.value = 1.5; atmosNode.connect(filterNode).connect(boost).connect(atmosGain).connect(masterGain);
        } else { atmosNode.connect(atmosGain).connect(masterGain); }
        atmosNode.start();
        if(customBuffer) {
            customNode = audioCtx.createBufferSource(); customNode.buffer = customBuffer; customNode.loop = true;
            customGain = audioCtx.createGain(); customGain.gain.value = document.getElementById('volCustom').value;
            customNode.connect(customGain).connect(masterGain); customNode.start();
        }
    }

    document.getElementById('volNoise').oninput = function() { if(atmosGain) atmosGain.gain.value = this.value; }
    document.getElementById('baseSlider').oninput = function() { document.getElementById('baseFreq').value = this.value; if(isEnvPlaying) updateBinaural(); };
    document.getElementById('beatSlider').oninput = function() { document.getElementById('beatFreq').value = this.value; if(isEnvPlaying) updateBinaural(); };
    document.getElementById('volBinaural').oninput = function() { if(gainBinaural) gainBinaural.gain.value = this.value; };
    function updateBinaural(forceStart = false) {
        if(!isEnvPlaying && !forceStart) return; 
        if(!oscLeft) {
            oscLeft = audioCtx.createOscillator(); const panLeft = audioCtx.createStereoPanner(); panLeft.pan.value = -1;
            oscRight = audioCtx.createOscillator(); const panRight = audioCtx.createStereoPanner(); panRight.pan.value = 1;
            gainBinaural = audioCtx.createGain(); gainBinaural.gain.value = document.getElementById('volBinaural').value;
            oscLeft.connect(panLeft).connect(gainBinaural); oscRight.connect(panRight).connect(gainBinaural);
            gainBinaural.connect(masterGain); oscLeft.start(); oscRight.start();
        }
        const base = parseFloat(document.getElementById('baseFreq').value);
        const beat = parseFloat(document.getElementById('beatFreq').value);
        oscLeft.frequency.value = base; oscRight.frequency.value = base + beat;
    }

    // Recorder
    async function scanDevices() { initAudio(); const s = document.getElementById('micSelect'); s.innerHTML = "<option>Scanning...</option>"; try { const t = await navigator.mediaDevices.getUserMedia({ audio: true }); t.getTracks().forEach(track => track.stop()); const d = await navigator.mediaDevices.enumerateDevices(); s.innerHTML = ""; const i = d.filter(x => x.kind === 'audioinput'); i.forEach((dev, idx) => { const o = document.createElement('option'); o.value = dev.deviceId; o.text = dev.label || `Mic ${idx + 1}`; s.appendChild(o); }); if(i.length===0) s.innerHTML = "<option value=''>Default Mic</option>"; } catch(e) { s.innerHTML = "<option value=''>Permission Denied</option>"; alert("Allow mic."); } }
    async function getStream() { const id = document.getElementById('micSelect').value; try { return await navigator.mediaDevices.getUserMedia({ audio: { deviceId: id ? { exact: id } : undefined } }); } catch (e) { return await navigator.mediaDevices.getUserMedia({ audio: true }); } }
    btnRecMic.onclick = async () => { initAudio(); try { if(activeStream) activeStream.getTracks().forEach(t=>t.stop()); activeStream = await getStream(); mediaRecorder = new MediaRecorder(activeStream); micChunks = []; const src = audioCtx.createMediaStreamSource(activeStream); if(!analyser) analyser = audioCtx.createAnalyser(); src.connect(analyser); visualizeMic(); mediaRecorder.ondataavailable = e => micChunks.push(e.data); mediaRecorder.onstop = async () => { const b = new Blob(micChunks, { type: 'audio/webm' }); const ab = await b.arrayBuffer(); const audBuf = await audioCtx.decodeAudioData(ab); applySafetyFade(audBuf); addClipToList(audBuf); if(activeStream) { activeStream.getTracks().forEach(t=>t.stop()); activeStream = null; } micMeter.style.width = '0%'; }; mediaRecorder.start(); isRecordingMic = true; recStartTime = Date.now(); btnRecMic.disabled = true; btnStopMic.disabled = false; document.getElementById('recTime').style.opacity = 1; micInterval = setInterval(updateRecTimer, 1000); } catch (e) { alert(e.message); } };
    btnStopMic.onclick = () => { if(isRecordingMic) { mediaRecorder.stop(); isRecordingMic = false; btnRecMic.disabled = false; btnStopMic.disabled = true; clearInterval(micInterval); document.getElementById('recTime').style.opacity = 0; } };
    function updateRecTimer() { const e = Math.floor((Date.now() - recStartTime) / 1000); document.getElementById('recTime').innerText = `${Math.floor(e/60)}:${(e%60).toString().padStart(2,'0')}`; }
    function visualizeMic() { if(!isRecordingMic && !isTestMicOn) return; requestAnimationFrame(visualizeMic); dataArray = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(dataArray); let sum = 0; for(let i=0; i<dataArray.length; i++) sum += dataArray[i]; micMeter.style.width = Math.min(100, (sum / dataArray.length) * 2) + "%"; }
    btnTestMic.addEventListener('mousedown', async () => { initAudio(); if(activeStream) activeStream.getTracks().forEach(t=>t.stop()); activeStream = await getStream(); testMicNode = audioCtx.createMediaStreamSource(activeStream); testMicGain = audioCtx.createGain(); testMicNode.connect(testMicGain).connect(masterGain); if(!analyser) analyser = audioCtx.createAnalyser(); testMicNode.connect(analyser); visualizeMic(); isTestMicOn = true; btnTestMic.style.background = "#22c55e"; });
    btnTestMic.addEventListener('mouseup', () => { if(isTestMicOn) { testMicNode.disconnect(); testMicGain.disconnect(); if(activeStream) activeStream.getTracks().forEach(t=>t.stop()); isTestMicOn = false; btnTestMic.style.background = "var(--warning)"; micMeter.style.width = '0%'; } });
    function addClipToList(buffer) { document.getElementById('emptyListMsg').style.display = 'none'; const id = clipIdCounter++; clips.push({ id, buffer, name: `Affirmation ${id}`, isPlaying: false, gainVal: 1.0, isAngelic: false }); renderClipList(); }
    function renderClipList() { const l = document.getElementById('clipList'); l.innerHTML = ""; clips.forEach(c => { const li = document.createElement('li'); li.className = `clip-item ${c.isPlaying ? 'playing' : ''}`; li.innerHTML = `<button onclick="toggleClip(${c.id})" class="${c.isPlaying ? 'btn-stop' : 'btn-play'}">${c.isPlaying ? 'Stop' : 'Loop'}</button><input type="text" class="clip-name" value="${c.name}" onchange="updateClipName(${c.id}, this.value)"><div class="checkbox-wrapper"><input type="checkbox" ${c.isAngelic ? 'checked' : ''} onchange="toggleAngelic(${c.id}, this.checked)">Angelic</div><input type="range" max="1.5" step="0.1" value="${c.gainVal}" oninput="updateClipVolume(${c.id}, this.value)" style="width:60px"><button onclick="deleteClip(${c.id})" style="color:#ef4444;background:none;">‚úñ</button>`; l.appendChild(li); }); }
    function toggleClip(id) { initAudio(); const c = clips.find(x => x.id === id); if(!c) return; if(c.isPlaying) { c.sourceNode.stop(); c.isPlaying = false; } else { const s = audioCtx.createBufferSource(); s.buffer = c.buffer; s.loop = true; let n = s; if(c.isAngelic) { const f = audioCtx.createBiquadFilter(); f.type='highpass'; f.frequency.value=350; s.connect(f); n=f; } const g = audioCtx.createGain(); g.gain.value = c.gainVal; n.connect(g).connect(masterGain); c.sourceNode = s; c.gainNode = g; s.start(); c.isPlaying = true; } renderClipList(); }
    function toggleAngelic(id, chk) { const c = clips.find(x => x.id === id); c.isAngelic = chk; if(c.isPlaying) { toggleClip(id); toggleClip(id); } }
    function updateClipVolume(id, val) { const c = clips.find(x => x.id === id); c.gainVal = val; if(c.gainNode) c.gainNode.gain.value = val; }
    function updateClipName(id, val) { clips.find(x => x.id === id).name = val; }
    function deleteClip(id) { const c = clips.find(x => x.id === id); if(c.isPlaying) c.sourceNode.stop(); clips = clips.filter(x => x.id !== id); renderClipList(); }
    async function handleFileUpload(i) { initAudio(); const f = i.files[0]; if(!f) return; try { const ab = await f.arrayBuffer(); customBuffer = await audioCtx.decodeAudioData(ab); document.getElementById('fileNameDisplay').innerText = f.name; if(isEnvPlaying) startAtmosphere(true); } catch(e) { alert("Error"); } }
    function updateCustomVol(v) { if(customGain) customGain.gain.value = v; }
    function applyPreset() {
        const val = document.getElementById('presetSelect').value;
        if(val === 'custom') return;
        const set = (base, beat) => { document.getElementById('baseFreq').value = base; document.getElementById('baseSlider').value = base; document.getElementById('beatFreq').value = beat; document.getElementById('beatSlider').value = beat; };
        if(val === 'schumann1') set(200, 7.83); else if(val === 'schumann2') set(200, 14.3); else if(val === 'schumann3') set(200, 20.8); else if(val === 'schumann4') set(200, 27.3); else if(val === 'schumann5') set(200, 33.8);
        else if(val === 'delta') set(100, 2); else if(val === 'theta') set(200, 6); else if(val === 'alpha') set(200, 10); else if(val === 'beta') set(200, 20); else if(val === 'gamma') set(200, 40);
        else if(val === '963') set(963, 0); else if(val === '852') set(852, 0); else if(val === '741') set(741, 0); else if(val === '693') set(693, 0); else if(val === '528') set(528, 0); else if(val === '417') set(417, 0); else if(val === '396') set(396, 0); else if(val === '285') set(285, 0); else if(val === '174') set(174, 0);
        if(isEnvPlaying) updateBinaural();
    }
</script>
</body>
</html>
