<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manifestation Mixer - Professional Edition</title>
    <style>
        :root { --primary: #8b5cf6; --bg: #0f172a; --panel: #1e293b; --text: #e2e8f0; --accent: #38bdf8; --success: #10b981; --danger: #ef4444; --warning: #f59e0b; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: var(--primary); margin-bottom: 20px; letter-spacing: 1px; text-transform: uppercase; border-bottom: 2px solid #334155; padding-bottom: 10px; }
        h2 { color: var(--accent); margin-top: 0; font-size: 1.2rem; border-bottom: 1px solid #334155; padding-bottom: 10px; margin-bottom: 15px; }
        
        .panel { background: var(--panel); padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #334155; }
        
        .control-group { margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px; }
        label { font-weight: bold; width: 140px; color: #cbd5e1; }
        input[type=range] { flex-grow: 1; cursor: pointer; accent-color: var(--primary); }
        
        button { background: var(--primary); color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold; transition: 0.2s; }
        button:hover { filter: brightness(1.2); }
        button:disabled { background: #475569; cursor: not-allowed; opacity: 0.6; }
        
        .btn-record { background: var(--danger); }
        .btn-test { background: var(--warning); color: #000; }
        .btn-stop { background: #64748b; }
        .btn-play { background: var(--success); }
        .btn-scan { background: #475569; font-size: 12px; padding: 8px; }
        
        select { padding: 8px; border-radius: 4px; background: #0f172a; color: white; border: 1px solid #475569; width: 100%; max-width: 300px; }
        input[type=text], input[type=number] { padding: 8px; border-radius: 4px; background: #0f172a; color: white; border: 1px solid #475569; }

        /* Sequencer Styles */
        .seq-list { list-style: none; padding: 0; margin-top: 10px; border: 1px solid #334155; border-radius: 6px; overflow: hidden; }
        .seq-item { background: #0f172a; padding: 10px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #334155; font-size: 0.9em; }
        .seq-item:last-child { border-bottom: none; }
        .seq-active { background: #1e3a8a; border-left: 4px solid var(--accent); }
        .seq-controls { display: flex; gap: 5px; margin-top: 10px; }
        
        /* Recording List Styles */
        .clip-list { list-style: none; padding: 0; margin: 0; }
        .clip-item { background: #0f172a; padding: 10px; border-radius: 8px; margin-bottom: 10px; display: flex; align-items: center; gap: 10px; border: 1px solid #334155; flex-wrap: wrap; }
        .clip-item.playing { border-color: var(--success); box-shadow: 0 0 10px rgba(16, 185, 129, 0.2); }
        .clip-name { flex-grow: 1; background: transparent; border: none; color: white; font-size: 1rem; min-width: 150px; }
        
        .file-upload { position: relative; overflow: hidden; display: inline-block; }
        .file-upload input[type=file] { position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; height: 100%; width: 100%; }
        
        .checkbox-wrapper { display: flex; align-items: center; gap: 5px; font-size: 0.9em; color: #cbd5e1; background: #334155; padding: 5px 10px; border-radius: 4px; }
        
        .info-box { background: #0f172a; padding: 15px; border-radius: 8px; font-size: 0.85em; border-left: 4px solid var(--primary); color: #94a3b8; margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px;}
        
        .meter-container { width: 100%; height: 6px; background: #334155; border-radius: 3px; overflow: hidden; margin-top: 5px;}
        .meter-fill { height: 100%; width: 0%; background: var(--success); transition: width 0.05s; }
        
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        .master-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: center; }
        @media (max-width: 600px) { .info-box { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div class="container">
    <h1>Manifestation Mixer</h1>

    <!-- 1. Voice Recorder -->
    <div class="panel">
        <h2>1. Voice Recordings</h2>
        <div class="control-group" style="background: #1e293b; padding: 10px; border-radius: 8px; border: 1px solid #334155;">
            <label>Input Device:</label>
            <div style="flex-grow: 1; display: flex; gap: 5px;">
                <select id="micSelect"><option value="">Default Microphone</option></select>
                <button onclick="scanDevices()" class="btn-scan">‚Üª Scan Inputs</button>
            </div>
        </div>

        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button id="btnTestMic" class="btn-test">üé§ Test Mic (Hold)</button>
            <div style="font-size: 0.8em; color: #94a3b8; align-self: center;">(Hold to check levels)</div>
        </div>

        <div class="control-group" style="justify-content: start;">
            <button id="btnRecMic" class="btn-record">‚óè Record New Clip</button>
            <button id="btnStopMic" class="btn-stop" disabled>‚ñ† Stop</button>
            <span id="recTime" style="font-family: monospace; color: var(--danger); opacity: 0;">00:00</span>
        </div>
        
        <div class="meter-container"><div id="micMeter" class="meter-fill"></div></div>

        <div style="margin-top: 20px;">
            <ul id="clipList" class="clip-list"></ul>
            <div id="emptyListMsg" style="color: #64748b; text-align: center; font-style: italic;">No recordings yet.</div>
        </div>
    </div>

    <!-- 2. Binaural Generator & Sequencer -->
    <div class="panel">
        <h2>2. Binaural Brainwave Engine</h2>
        
        <!-- Live Controls -->
        <div class="control-group">
            <label>Load Preset</label>
            <select id="presetSelect" onchange="applyPreset()">
                <option value="custom">-- Select a Preset --</option>
                <optgroup label="Schumann Resonances (Earth)">
                    <option value="schumann1">7.83Hz (Grounding/Om)</option>
                    <option value="schumann2">14.3Hz (Harmonic 2)</option>
                    <option value="schumann3">20.8Hz (Harmonic 3)</option>
                    <option value="schumann4">27.3Hz (Harmonic 4)</option>
                    <option value="schumann5">33.8Hz (Harmonic 5)</option>
                </optgroup>
                <optgroup label="Brainwaves">
                    <option value="delta">Delta (Deep Sleep - 2Hz)</option>
                    <option value="theta">Theta (Meditation - 6Hz)</option>
                    <option value="alpha">Alpha (Relaxation - 10Hz)</option>
                    <option value="beta">Beta (Focus - 20Hz)</option>
                    <option value="gamma">Gamma (High Energy - 40Hz)</option>
                </optgroup>
                <optgroup label="Solfeggio (Pure Tones)">
                    <option value="528">528Hz (Miracles)</option>
                    <option value="417">417Hz (Wipe Negativity)</option>
                    <!-- Others included in logic -->
                </optgroup>
            </select>
        </div>
        <div class="control-group">
            <label>Base Tone (Hz)</label>
            <input type="number" id="baseFreq" value="200" style="width: 60px;">
            <input type="range" id="baseSlider" min="50" max="963" value="200">
        </div>
        <div class="control-group">
            <label>Beat Diff (Hz)</label>
            <input type="number" id="beatFreq" value="7.83" style="width: 60px;">
            <input type="range" id="beatSlider" min="0" max="55" step="0.01" value="7.83">
        </div>
        <div class="control-group">
            <label>Beat Volume</label>
            <input type="range" id="volBinaural" min="0" max="0.5" step="0.01" value="0.2">
        </div>

        <hr style="border-color: #334155; margin: 15px 0;">
        
        <!-- Sequence Engine -->
        <h3 style="font-size: 1rem; color: var(--accent); margin-bottom: 5px;">3. Frequency Sequencer (Ramping)</h3>
        <p style="font-size:0.8em; color:#94a3b8;">Create a journey. The frequency will slowly slide to the target over the duration.</p>
        
        <div class="seq-controls" style="background:#0f172a; padding:10px; border-radius:6px; align-items:center;">
            <label style="width:auto;">Target Hz:</label>
            <input type="number" id="seqTarget" value="4" style="width:50px;" min="0" max="55">
            <label style="width:auto; margin-left:10px;">Mins:</label>
            <input type="number" id="seqMins" value="10" style="width:50px;" min="1">
            <button onclick="addSequenceStep()" style="background:var(--accent); font-size:12px; margin-left:auto;">+ Add Stage</button>
        </div>

        <ul id="sequenceList" class="seq-list" style="display:none;"></ul>
        
        <div id="seqStatus" style="margin-top:10px; font-family:monospace; color:var(--success); min-height:20px;"></div>
        <button id="btnStartSeq" onclick="toggleSequence()" style="width:100%; margin-top:5px; display:none;">‚ñ∂ Start Sequence</button>
    </div>

    <!-- 3. Atmosphere -->
    <div class="panel">
        <h2>4. Atmosphere</h2>
        <div class="control-group">
            <label>Generated:</label>
            <select id="noiseType" onchange="if(isEnvPlaying) startAtmosphere(true)">
                <option value="ocean">üåä Ocean Waves (Dynamic)</option>
                <option value="deep_brown">üåë Deep Brown (Smoothed)</option>
                <option value="brown">üü§ Brown Noise (Deep Rumble)</option>
                <option value="pink">üå∏ Pink Noise (Balanced)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Gen Volume</label>
            <input type="range" id="volNoise" min="0" max="0.8" step="0.01" value="0.3">
        </div>
        
        <hr style="border-color: #334155; margin: 15px 0;">
        
        <div class="control-group">
            <label>Custom Audio:</label>
            <div class="file-upload">
                <button class="btn-scan" style="width: 100%;">üìÅ Upload File (MP3/WAV)</button>
                <input type="file" id="customFile" accept="audio/*" onchange="handleFileUpload(this)">
            </div>
            <span id="fileNameDisplay" style="font-size: 0.8em; color: var(--accent); margin-left: 10px;"></span>
        </div>
        <div class="control-group">
            <label>Custom Vol</label>
            <input type="range" id="volCustom" min="0" max="1" step="0.01" value="0.5" oninput="updateCustomVol(this.value)">
        </div>
    </div>

    <!-- 5. Master Controls -->
    <div class="panel" style="border: 2px solid var(--primary);">
        <h2>5. Master Controls</h2>
        <div class="master-grid">
            <div>
                <button id="btnEnvToggle" onclick="toggleEnvironment()" style="width: 100%; padding: 15px;">‚ñ∂ Preview Mix</button>
                <p style="font-size: 0.8em; color: #94a3b8; margin-top:5px;">Hear beats, atmos & custom</p>
            </div>
            <div>
                <div style="margin-bottom: 5px;">
                    <input type="text" id="fileName" value="manifestation_mix" placeholder="Filename" style="width: 100%; text-align: center; box-sizing: border-box; background: #334155; color:white; border:none; padding:5px;">
                </div>
                <button id="btnExport" onclick="startExport()" style="width: 100%; padding: 15px; background: var(--success);">üíæ Download Master Mix</button>
                <p id="exportStatus" style="font-size: 0.8em; color: var(--accent); margin-top:5px; height: 1.2em;"></p>
            </div>
        </div>
    </div>

    <!-- Guide -->
    <div class="panel">
        <h2>Frequency Guide</h2>
        <div class="info-box">
            <div>
                <strong>üß† Brainwaves</strong><br>
                <ul style="padding-left: 20px; margin-top: 5px;">
                    <li><strong>Delta (1-4Hz):</strong> Deep Healing</li>
                    <li><strong>Theta (4-8Hz):</strong> Meditation</li>
                    <li><strong>Schumann (7.83Hz):</strong> Earth Grounding</li>
                    <li><strong>Alpha (8-14Hz):</strong> Relaxation</li>
                    <li><strong>Beta (14-30Hz):</strong> Focus</li>
                    <li><strong>Gamma (30-50Hz):</strong> Insight</li>
                </ul>
            </div>
            <div>
                <strong>‚ú® Solfeggio</strong><br>
                <ul style="padding-left: 20px; margin-top: 5px;">
                    <li><strong>174/285 Hz:</strong> Pain & Healing</li>
                    <li><strong>396/417 Hz:</strong> Fear & Change</li>
                    <li><strong>528 Hz:</strong> Miracles</li>
                    <li><strong>639/741 Hz:</strong> Relationships & Intuition</li>
                    <li><strong>852/963 Hz:</strong> Spiritual Order</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    let audioCtx, masterGain, mainDestination;
    let oscLeft, oscRight, gainBinaural;
    let atmosNode, atmosGain, lfoNode, filterNode;
    let customBuffer, customNode, customGain;
    let isEnvPlaying = false; 

    // Recorder Vars
    let mediaRecorder, micChunks = [];
    let isRecordingMic = false, isTestMicOn = false;
    let testMicNode, testMicGain, recStartTime, micInterval;
    let analyser, dataArray, activeStream = null;
    let clips = [], clipIdCounter = 1;
    let masterRecorder, masterChunks = [], isExporting = false;

    // --- SEQUENCER VARS ---
    let sequenceSteps = [];
    let isSeqRunning = false;
    let seqInterval;
    let seqStartTime;
    let currentStepIndex = 0;
    let startHz = 0;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            mainDestination = audioCtx.createMediaStreamDestination();
            masterGain.connect(mainDestination);
        }
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
    }

    // --- SEQUENCER LOGIC ---
    function addSequenceStep() {
        const target = parseFloat(document.getElementById('seqTarget').value);
        const mins = parseFloat(document.getElementById('seqMins').value);
        sequenceSteps.push({ target: target, mins: mins });
        renderSequenceList();
        document.getElementById('sequenceList').style.display = 'block';
        document.getElementById('btnStartSeq').style.display = 'block';
    }

    function renderSequenceList() {
        const list = document.getElementById('sequenceList');
        list.innerHTML = "";
        sequenceSteps.forEach((step, index) => {
            const li = document.createElement('li');
            li.className = 'seq-item';
            li.id = `seq-item-${index}`;
            li.innerHTML = `
                <span>Stage ${index+1}: <strong>${step.target}Hz</strong> for <strong>${step.mins}m</strong></span>
                <button onclick="removeSeqStep(${index})" style="background:transparent; color:#ef4444; padding:2px;">‚úñ</button>
            `;
            list.appendChild(li);
        });
    }

    function removeSeqStep(index) {
        sequenceSteps.splice(index, 1);
        renderSequenceList();
        if(sequenceSteps.length === 0) {
            document.getElementById('sequenceList').style.display = 'none';
            document.getElementById('btnStartSeq').style.display = 'none';
        }
    }

    function toggleSequence() {
        initAudio();
        const btn = document.getElementById('btnStartSeq');
        if(isSeqRunning) {
            // STOP
            clearInterval(seqInterval);
            isSeqRunning = false;
            btn.innerText = "‚ñ∂ Start Sequence";
            btn.style.background = "var(--primary)";
            document.getElementById('seqStatus').innerText = "";
            document.querySelectorAll('.seq-item').forEach(el => el.classList.remove('seq-active'));
        } else {
            // START
            // Force Environment On if off
            if(!isEnvPlaying) toggleEnvironment();
            
            isSeqRunning = true;
            currentStepIndex = 0;
            startHz = parseFloat(document.getElementById('beatFreq').value); // Start from current
            runSequenceStep();
            
            btn.innerText = "‚èπ Stop Sequence";
            btn.style.background = "#64748b";
        }
    }

    function runSequenceStep() {
        if(currentStepIndex >= sequenceSteps.length) {
            toggleSequence(); // Finished
            document.getElementById('seqStatus').innerText = "Sequence Complete!";
            return;
        }

        const step = sequenceSteps[currentStepIndex];
        const durationSecs = step.mins * 60;
        const startTime = Date.now();
        const initialHz = startHz; 
        
        // Highlight UI
        document.querySelectorAll('.seq-item').forEach(el => el.classList.remove('seq-active'));
        document.getElementById(`seq-item-${currentStepIndex}`).classList.add('seq-active');

        clearInterval(seqInterval);
        seqInterval = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            if(elapsed >= durationSecs) {
                // End of step
                updateBeatFreq(step.target);
                startHz = step.target; // Next step starts here
                currentStepIndex++;
                runSequenceStep();
            } else {
                // Linear Ramp Calculation
                const progress = elapsed / durationSecs;
                const currentHz = initialHz + (step.target - initialHz) * progress;
                updateBeatFreq(currentHz);
                
                // Update UI status
                const remaining = durationSecs - elapsed;
                const min = Math.floor(remaining/60);
                const sec = Math.floor(remaining%60).toString().padStart(2,'0');
                document.getElementById('seqStatus').innerText = `Ramping to ${step.target}Hz... ${currentHz.toFixed(2)}Hz (${min}:${sec})`;
            }
        }, 100); // Update every 100ms
    }

    function updateBeatFreq(hz) {
        document.getElementById('beatFreq').value = hz.toFixed(2);
        document.getElementById('beatSlider').value = hz;
        if(isEnvPlaying) updateBinaural();
    }

    // --- STANDARD AUDIO LOGIC ---

    function applySafetyFade(buffer) {
        const fadeLength = 2000; 
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
            const data = buffer.getChannelData(ch);
            const len = data.length;
            for (let i = 0; i < fadeLength && i < len; i++) { data[i] *= (i / fadeLength); }
            for (let i = 0; i < fadeLength && i < len; i++) { data[len - 1 - i] *= (i / fadeLength); }
        }
    }

    async function scanDevices() {
        initAudio();
        const micSelect = document.getElementById('micSelect');
        micSelect.innerHTML = "<option>Scanning...</option>";
        try {
            const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            tempStream.getTracks().forEach(t => t.stop()); 
            const devices = await navigator.mediaDevices.enumerateDevices();
            micSelect.innerHTML = ""; 
            const audioInputs = devices.filter(device => device.kind === 'audioinput');
            audioInputs.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `Microphone ${index + 1}`;
                micSelect.appendChild(option);
            });
            if(audioInputs.length === 0) micSelect.innerHTML = "<option value=''>Default Microphone</option>";
        } catch(e) { micSelect.innerHTML = "<option value=''>Permission Denied</option>"; alert("Allow mic access."); }
    }

    async function getStream() {
        const deviceId = document.getElementById('micSelect').value;
        const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined, echoCancellation: false, noiseSuppression: false, autoGainControl: false } };
        try { return await navigator.mediaDevices.getUserMedia(constraints); } 
        catch (e) { return await navigator.mediaDevices.getUserMedia({ audio: true }); }
    }

    // Recorder
    const btnTestMic = document.getElementById('btnTestMic');
    const btnRecMic = document.getElementById('btnRecMic');
    const btnStopMic = document.getElementById('btnStopMic');
    const recTimeDisplay = document.getElementById('recTime');
    const micMeter = document.getElementById('micMeter');

    const startTest = async () => {
        initAudio();
        try {
            if(activeStream) activeStream.getTracks().forEach(t=>t.stop());
            activeStream = await getStream();
            testMicNode = audioCtx.createMediaStreamSource(activeStream);
            testMicGain = audioCtx.createGain();
            testMicGain.gain.value = 1.0;
            testMicNode.connect(testMicGain).connect(masterGain);
            if(!analyser) analyser = audioCtx.createAnalyser();
            testMicNode.connect(analyser);
            visualizeMic();
            isTestMicOn = true;
            btnTestMic.innerText = "üé§ Listening...";
            btnTestMic.style.background = "#22c55e"; 
        } catch (e) { console.error(e); }
    };
    const stopTest = () => {
        if(isTestMicOn) {
            if(testMicNode) { testMicNode.disconnect(); testMicNode = null; }
            if(testMicGain) { testMicGain.disconnect(); testMicGain = null; }
            if(activeStream) { activeStream.getTracks().forEach(t=>t.stop()); activeStream = null; }
            isTestMicOn = false;
            btnTestMic.innerText = "üé§ Test Mic (Hold)";
            btnTestMic.style.background = "var(--warning)";
            micMeter.style.width = '0%';
        }
    };
    btnTestMic.addEventListener('mousedown', startTest);
    btnTestMic.addEventListener('mouseup', stopTest);
    btnTestMic.addEventListener('touchstart', (e) => { e.preventDefault(); startTest(); });
    btnTestMic.addEventListener('touchend', (e) => { e.preventDefault(); stopTest(); });

    btnRecMic.onclick = async () => {
        initAudio();
        try {
            if(activeStream) activeStream.getTracks().forEach(t=>t.stop());
            activeStream = await getStream();
            mediaRecorder = new MediaRecorder(activeStream);
            micChunks = [];
            const source = audioCtx.createMediaStreamSource(activeStream);
            if(!analyser) analyser = audioCtx.createAnalyser();
            source.connect(analyser);
            visualizeMic();
            mediaRecorder.ondataavailable = e => micChunks.push(e.data);
            mediaRecorder.onstop = async () => {
                const blob = new Blob(micChunks, { type: 'audio/webm' });
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                applySafetyFade(audioBuffer);
                addClipToList(audioBuffer);
                if(activeStream) { activeStream.getTracks().forEach(t=>t.stop()); activeStream = null; }
                micMeter.style.width = '0%';
            };
            mediaRecorder.start();
            isRecordingMic = true;
            recStartTime = Date.now();
            btnRecMic.disabled = true;
            btnStopMic.disabled = false;
            recTimeDisplay.style.opacity = 1;
            micInterval = setInterval(updateRecTimer, 1000);
        } catch (err) { alert("Mic Error: " + err.message); }
    };
    btnStopMic.onclick = () => {
        if(isRecordingMic) {
            mediaRecorder.stop();
            isRecordingMic = false;
            btnRecMic.disabled = false;
            btnStopMic.disabled = true;
            clearInterval(micInterval);
            recTimeDisplay.style.opacity = 0;
            recTimeDisplay.innerText = "00:00";
        }
    };
    function updateRecTimer() {
        const elapsed = Math.floor((Date.now() - recStartTime) / 1000);
        const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const sec = (elapsed % 60).toString().padStart(2, '0');
        recTimeDisplay.innerText = `${min}:${sec}`;
    }
    function visualizeMic() {
        if(!isRecordingMic && !isTestMicOn) return;
        requestAnimationFrame(visualizeMic);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
        micMeter.style.width = Math.min(100, (sum / dataArray.length) * 2) + "%";
    }

    function addClipToList(buffer) {
        document.getElementById('emptyListMsg').style.display = 'none';
        const id = clipIdCounter++;
        const clip = { id, buffer, name: `Affirmation ${id}`, isPlaying: false, gainVal: 1.0, startTime: 0, isAngelic: false };
        clips.push(clip);
        renderClipList();
    }
    function renderClipList() {
        const list = document.getElementById('clipList');
        list.innerHTML = "";
        clips.forEach(clip => {
            const li = document.createElement('li');
            li.className = `clip-item ${clip.isPlaying ? 'playing' : ''}`;
            li.innerHTML = `
                <button onclick="toggleClip(${clip.id})" class="${clip.isPlaying ? 'btn-stop' : 'btn-play'}">
                    ${clip.isPlaying ? '‚ùö‚ùö Stop' : '‚ñ∂ Loop'}
                </button>
                <input type="text" class="clip-name" value="${clip.name}" onchange="updateClipName(${clip.id}, this.value)">
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="ang_${clip.id}" ${clip.isAngelic ? 'checked' : ''} onchange="toggleAngelic(${clip.id}, this.checked)">
                    <label for="ang_${clip.id}" style="width:auto; font-weight:normal; color:#cbd5e1; cursor:pointer;">‚ú® Angelic</label>
                </div>
                <input type="range" min="0" max="1.5" step="0.1" value="${clip.gainVal}" 
                       oninput="updateClipVolume(${clip.id}, this.value)" style="max-width:80px">
                <button onclick="deleteClip(${clip.id})" style="background:transparent; color:#ef4444; padding:5px; font-size:18px;">‚úñ</button>
            `;
            list.appendChild(li);
        });
    }

    function toggleClip(id) {
        initAudio(); 
        const clip = clips.find(c => c.id === id);
        if(!clip) return;
        if (clip.isPlaying) {
            if(clip.sourceNode) clip.sourceNode.stop();
            clip.isPlaying = false;
        } else {
            const source = audioCtx.createBufferSource();
            source.buffer = clip.buffer;
            source.loop = true;
            let lastNode = source;
            if(clip.isAngelic) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 350; 
                source.connect(filter); lastNode = filter;
            }
            const gain = audioCtx.createGain();
            gain.gain.value = clip.gainVal;
            lastNode.connect(gain).connect(masterGain);
            clip.sourceNode = source;
            clip.gainNode = gain;
            clip.startTime = audioCtx.currentTime;
            source.start();
            clip.isPlaying = true;
        }
        renderClipList();
    }
    
    function toggleAngelic(id, checked) {
        const clip = clips.find(c => c.id === id);
        clip.isAngelic = checked;
        if(clip.isPlaying) { toggleClip(id); toggleClip(id); } 
    }
    function updateClipVolume(id, val) {
        const clip = clips.find(c => c.id === id);
        clip.gainVal = val;
        if(clip.gainNode) clip.gainNode.gain.linearRampToValueAtTime(val, audioCtx.currentTime + 0.1);
    }
    function updateClipName(id, name) { clips.find(c => c.id === id).name = name; }
    function deleteClip(id) {
        const clip = clips.find(c => c.id === id);
        if(clip.isPlaying && clip.sourceNode) clip.sourceNode.stop();
        clips = clips.filter(c => c.id !== id);
        renderClipList();
    }

    async function handleFileUpload(input) {
        initAudio();
        const file = input.files[0];
        if(!file) return;
        document.getElementById('fileNameDisplay').innerText = "Loading: " + file.name;
        try {
            const arrayBuffer = await file.arrayBuffer();
            customBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            document.getElementById('fileNameDisplay').innerText = "Loaded: " + file.name;
            if(isEnvPlaying) startAtmosphere(true);
        } catch(e) { alert("Error decoding audio file."); }
    }
    
    function updateCustomVol(val) { if(customGain) customGain.gain.value = val; }

    function toggleEnvironment() {
        initAudio();
        const btn = document.getElementById('btnEnvToggle');
        if (isEnvPlaying) {
            if(oscLeft) { oscLeft.stop(); oscLeft = null; }
            if(oscRight) { oscRight.stop(); oscRight = null; }
            if(atmosNode) { atmosNode.stop(); atmosNode = null; }
            if(lfoNode) { lfoNode.stop(); lfoNode = null; }
            if(customNode) { customNode.stop(); customNode = null; }
            isEnvPlaying = false;
            
            // Also stop Sequencer if running
            if(isSeqRunning) toggleSequence();
            
            btn.innerText = "‚ñ∂ Preview Mix";
            btn.style.background = "var(--primary)";
        } else {
            isEnvPlaying = true;
            updateBinaural(true); 
            startAtmosphere();
            btn.innerText = "‚èπ Stop Mix";
            btn.style.background = "#64748b";
        }
    }

    function updateBinaural(forceStart = false) {
        if(!isEnvPlaying && !forceStart) return; 
        if(!oscLeft) {
            oscLeft = audioCtx.createOscillator();
            const panLeft = audioCtx.createStereoPanner();
            panLeft.pan.value = -1;
            oscRight = audioCtx.createOscillator();
            const panRight = audioCtx.createStereoPanner();
            panRight.pan.value = 1;
            gainBinaural = audioCtx.createGain();
            gainBinaural.gain.value = document.getElementById('volBinaural').value;
            oscLeft.connect(panLeft).connect(gainBinaural);
            oscRight.connect(panRight).connect(gainBinaural);
            gainBinaural.connect(masterGain);
            oscLeft.start();
            oscRight.start();
        }
        const base = parseFloat(document.getElementById('baseFreq').value);
        const beat = parseFloat(document.getElementById('beatFreq').value);
        oscLeft.frequency.value = base;
        oscRight.frequency.value = base + beat;
    }

    document.getElementById('baseSlider').oninput = function() { document.getElementById('baseFreq').value = this.value; if(isEnvPlaying) updateBinaural(); };
    document.getElementById('beatSlider').oninput = function() { document.getElementById('beatFreq').value = this.value; if(isEnvPlaying) updateBinaural(); };
    document.getElementById('volBinaural').oninput = function() { if(gainBinaural) gainBinaural.gain.value = this.value; };
    
    function startAtmosphere(restart = false) {
        if(restart && atmosNode) { atmosNode.stop(); if(lfoNode) lfoNode.stop(); }
        if(restart && customNode) { customNode.stop(); customNode = null; }
        if(!isEnvPlaying && !restart) return; 

        const type = document.getElementById('noiseType').value;
        const bufferSize = audioCtx.sampleRate * 2;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
        for (let i = 0; i < bufferSize; i++) {
            let white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168981;
            data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            data[i] *= 0.11; 
            b6 = white * 0.115926;
        }
        if (type === 'brown' || type === 'deep_brown') {
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                let white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 8.0; 
            }
        }
        atmosNode = audioCtx.createBufferSource();
        atmosNode.buffer = buffer;
        atmosNode.loop = true;
        atmosGain = audioCtx.createGain();
        atmosGain.gain.value = document.getElementById('volNoise').value;

        if (type === 'ocean') {
            filterNode = audioCtx.createBiquadFilter();
            filterNode.type = 'lowpass'; filterNode.frequency.value = 400; 
            const waveGain = audioCtx.createGain();
            lfoNode = audioCtx.createOscillator();
            lfoNode.type = 'sine'; lfoNode.frequency.value = 0.15; 
            const lfoStrength = audioCtx.createGain(); lfoStrength.gain.value = 0.8; 
            lfoNode.connect(lfoStrength).connect(waveGain.gain);
            atmosNode.connect(filterNode).connect(waveGain).connect(atmosGain).connect(masterGain);
            lfoNode.start();
        } 
        else if (type === 'deep_brown') {
            filterNode = audioCtx.createBiquadFilter();
            filterNode.type = 'lowpass'; filterNode.frequency.value = 150; 
            const boost = audioCtx.createGain(); boost.gain.value = 1.5;
            atmosNode.connect(filterNode).connect(boost).connect(atmosGain).connect(masterGain);
        }
        else { atmosNode.connect(atmosGain).connect(masterGain); }
        atmosNode.start();
        
        if(customBuffer) {
            customNode = audioCtx.createBufferSource();
            customNode.buffer = customBuffer;
            customNode.loop = true;
            customGain = audioCtx.createGain();
            customGain.gain.value = document.getElementById('volCustom').value;
            customNode.connect(customGain).connect(masterGain);
            customNode.start();
        }
    }
    document.getElementById('volNoise').oninput = function() { if(atmosGain) atmosGain.gain.value = this.value; }

    function applyPreset() {
        const val = document.getElementById('presetSelect').value;
        if(val === 'custom') return;
        const set = (base, beat) => {
            document.getElementById('baseFreq').value = base;
            document.getElementById('baseSlider').value = base;
            document.getElementById('beatFreq').value = beat;
            document.getElementById('beatSlider').value = beat;
        };
        // Schumann
        if(val === 'schumann1') set(200, 7.83);
        else if(val === 'schumann2') set(200, 14.3);
        else if(val === 'schumann3') set(200, 20.8);
        else if(val === 'schumann4') set(200, 27.3);
        else if(val === 'schumann5') set(200, 33.8);
        // Brainwaves
        else if(val === 'delta') set(100, 2);
        else if(val === 'theta') set(200, 6);
        else if(val === 'alpha') set(200, 10);
        else if(val === 'beta') set(200, 20);
        else if(val === 'gamma') set(200, 40);
        // Solfeggio
        else if(val === '528') set(528, 0);
        else if(val === '417') set(417, 0);
        
        if(isEnvPlaying) updateBinaural();
    }
    
    // --- EXPORT ---
    function startExport() {
        initAudio();
        const btn = document.getElementById('btnExport');
        const status = document.getElementById('exportStatus');

        if(isExporting) {
            let maxDuration = 0;
            let targetClip = null;
            clips.forEach(c => {
                if(c.isPlaying && c.buffer.duration > maxDuration) {
                    maxDuration = c.buffer.duration;
                    targetClip = c;
                }
            });

            if(targetClip) {
                const now = audioCtx.currentTime;
                const elapsed = now - targetClip.startTime;
                const duration = targetClip.buffer.duration;
                const remaining = duration - (elapsed % duration);
                const adjust = remaining - 0.05; 
                const waitTime = adjust > 0 ? adjust : 0;
                status.innerText = "Finishing loop... (" + waitTime.toFixed(2) + "s)";
                btn.disabled = true; 
                setTimeout(() => { finalizeExport(btn, status); }, waitTime * 1000);
            } else { finalizeExport(btn, status); }
            return;
        }

        masterRecorder = new MediaRecorder(mainDestination.stream);
        masterChunks = [];
        masterRecorder.ondataavailable = e => masterChunks.push(e.data);
        masterRecorder.onstop = e => {
            const blob = new Blob(masterChunks, { 'type' : 'audio/wav; codecs=MS_PCM' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url; 
            const nameInput = document.getElementById('fileName').value || "manifestation_mix";
            const safeName = nameInput.replace(/[^a-z0-9_\-\.]/gi, '_');
            a.download = safeName + ".wav";
            a.click();
            status.innerText = "Download Started!";
        };
        masterRecorder.start();
        isExporting = true;
        btn.innerText = "‚èπ Stop (Aligns to Loop)";
        btn.style.background = "var(--danger)";
        btn.classList.add('blink');
        status.innerText = "Recording... Press Stop to finish loop.";
    }

    function finalizeExport(btn, status) {
        masterRecorder.stop();
        isExporting = false;
        btn.disabled = false;
        btn.innerText = "üíæ Download Master Mix";
        btn.style.background = "var(--success)";
        btn.classList.remove('blink');
    }
</script>
</body>
</html>
